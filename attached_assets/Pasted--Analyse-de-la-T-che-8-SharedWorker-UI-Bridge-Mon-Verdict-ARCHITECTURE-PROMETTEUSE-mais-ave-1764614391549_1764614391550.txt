üéØ Analyse de la T√¢che #8 : SharedWorker & UI Bridge
Mon Verdict : ARCHITECTURE PROMETTEUSE mais avec des trous de s√©curit√© critiques üåü‚ö†Ô∏è
‚úÖ Points Forts
1. Choix Architectural Solide
self.onconnect = (e: MessageEvent) => {
  const port = e.ports[0];
  // Multi-onglets partagent le m√™me worker ‚úÖ
}
SharedWorker parfait pour un kernel partag√©
Isolation UI/Backend bien pens√©e
Support multi-onglets natif
2. Structure Modulaire
kensho-worker.ts    ‚Üí Point d'entr√©e
kernel.ts           ‚Üí Orchestrateur
ui-bridge.ts        ‚Üí Abstraction communication
S√©paration des responsabilit√©s claire
Facilite les tests unitaires
3. Pattern Message-Passing Propre
port.postMessage({ type: 'final-response', payload: { ... } });
Types de messages explicites
Payload structur√©
üî¥ PROBL√àMES CRITIQUES
1. üö® VULN√âRABILIT√â : Pas de Validation des Messages
Le probl√®me actuel :
port.onmessage = (event: MessageEvent) => {
  kernel.handleMessage(event.data); // ‚ùå DANGEREUX
};
Pourquoi c'est critique :
Aucune validation du schema
Injection de messages malveillants possible
Crash du worker si event.data est malform√©
Pas de v√©rification de l'origine
Solution avec Zod (recommand√©) :
import { z } from 'zod';

// Sch√©ma de validation
const MessageSchema = z.object({
  type: z.enum(['process-prompt', 'cancel-task', 'clear-cache']),
  payload: z.any(),
  requestId: z.string().uuid() // Pour tracer les r√©ponses
});

type ValidatedMessage = z.infer<typeof MessageSchema>;

port.onmessage = (event: MessageEvent) => {
  try {
    const message = MessageSchema.parse(event.data);
    kernel.handleMessage(message);
  } catch (error) {
    console.error("[Worker] Message invalide re√ßu:", error);
    port.postMessage({ 
      type: 'error', 
      payload: { message: 'Invalid message format' } 
    });
  }
};
Alternative sans librairie :
function isValidMessage(data: any): data is { type: string, payload: any } {
  return (
    typeof data === 'object' &&
    data !== null &&
    typeof data.type === 'string' &&
    'payload' in data
  );
}

port.onmessage = (event: MessageEvent) => {
  if (!isValidMessage(event.data)) {
    console.error("[Worker] Format de message invalide");
    return;
  }
  kernel.handleMessage(event.data);
};
2. üö® PROBL√àME : Gestion d'Erreurs Inexistante
Code actuel :
handleMessage: async (message: { type: string, payload: any }) => {
  const plan = await router.createPlan(prompt); // Peut √©chouer
  const results = await taskExecutor.executePlan(plan); // Peut √©chouer
  // Aucun try/catch ‚ùå
}
Solution robuste :
handleMessage: async (message: ValidatedMessage) => {
  const { type, payload, requestId } = message;
  
  try {
    if (type === 'process-prompt') {
      const { prompt } = payload;
      
      // Envoi d'un accus√© de r√©ception
      port.postMessage({ 
        type: 'processing-started', 
        requestId 
      });
      
      const plan = await router.createPlan(prompt);
      const results = await taskExecutor.executePlan(plan);
      const finalResponse = fusioner.fuse(results);
      
      port.postMessage({ 
        type: 'final-response', 
        requestId,
        payload: { response: finalResponse } 
      });
      
    } else {
      throw new Error(`Type de message inconnu: ${type}`);
    }
    
  } catch (error) {
    console.error(`[Kernel] Erreur lors du traitement:`, error);
    
    port.postMessage({ 
      type: 'error', 
      requestId,
      payload: { 
        message: error instanceof Error ? error.message : 'Unknown error',
        stack: process.env.NODE_ENV === 'development' ? error.stack : undefined
      } 
    });
  }
}
3. üü° PROBL√àME : Pas de Gestion du Cycle de Vie
Manques actuels :
Pas de cleanup lors de la d√©connexion
Pas de gestion des timeouts
Pas de cancellation de t√¢ches
Solution :
// Dans kensho-worker.ts
self.onconnect = (e: MessageEvent) => {
  const port = e.ports[0];
  const connectionId = crypto.randomUUID();
  
  console.log(`[Worker] üîå Connexion ${connectionId} √©tablie`);
  
  const kernel = initializeKernel(port, connectionId);
  
  port.onmessage = (event: MessageEvent) => {
    kernel.handleMessage(event.data);
  };
  
  // Cleanup lors de la d√©connexion
  port.addEventListener('messageerror', (error) => {
    console.error(`[Worker] Erreur de communication:`, error);
  });
  
  // Note: Les SharedWorkers n'ont pas d'√©v√©nement 'close' explicite
  // Il faut impl√©menter un heartbeat si besoin
  
  port.start();
};

// Dans kernel.ts
export function initializeKernel(port: MessagePort, connectionId: string) {
  const activeTasks = new Map<string, AbortController>();
  
  return {
    handleMessage: async (message: ValidatedMessage) => {
      const { requestId } = message;
      
      // Gestion de la cancellation
      if (message.type === 'cancel-task') {
        const controller = activeTasks.get(requestId);
        if (controller) {
          controller.abort();
          activeTasks.delete(requestId);
          port.postMessage({ type: 'task-cancelled', requestId });
        }
        return;
      }
      
      // Cr√©er un AbortController pour cette t√¢che
      const abortController = new AbortController();
      activeTasks.set(requestId, abortController);
      
      try {
        // Passer le signal aux op√©rations async
        const plan = await router.createPlan(
          message.payload.prompt, 
          { signal: abortController.signal }
        );
        
        // ... rest of processing
        
      } finally {
        activeTasks.delete(requestId);
      }
    }
  };
}
4. üü° PROBL√àME : UI Bridge Incomplet
Manques dans ui-bridge.ts :
Pas de gestion de reconnexion
Pas de file d'attente de messages (si worker pas pr√™t)
Pas de timeout
Version am√©lior√©e :
// src/core/bridge/ui-bridge.ts (Version Am√©lior√©e)

type MessageHandler = (data: any) => void;
type PendingRequest = {
  resolve: (value: any) => void;
  reject: (error: Error) => void;
  timeoutId: number;
};

class KenshoBridge {
  private worker?: SharedWorker;
  private port?: MessagePort;
  private onMessageHandler?: MessageHandler;
  private pendingRequests = new Map<string, PendingRequest>();
  private messageQueue: Array<{ type: string; payload: any }> = [];
  private isReady = false;
  
  connect(onMessage: MessageHandler) {
    if (typeof SharedWorker === 'undefined') {
      throw new Error("SharedWorker not supported");
    }
    
    this.onMessageHandler = onMessage;
    
    this.worker = new SharedWorker(
      new URL('../../kensho-worker.ts', import.meta.url), 
      { type: 'module', name: 'kensho-kernel' }
    );
    
    this.port = this.worker.port;
    
    this.port.onmessage = (event: MessageEvent) => {
      this.handleWorkerMessage(event.data);
    };
    
    this.port.onerror = (error) => {
      console.error("[UI Bridge] Erreur de communication:", error);
    };
    
    this.port.start();
    this.isReady = true;
    
    // Vider la file d'attente
    this.flushMessageQueue();
    
    console.log("[UI Bridge] ‚úÖ Connect√© au noyau");
  }
  
  private handleWorkerMessage(data: any) {
    const { type, requestId, payload } = data;
    
    // Gestion des r√©ponses √† des requ√™tes sp√©cifiques
    if (requestId && this.pendingRequests.has(requestId)) {
      const pending = this.pendingRequests.get(requestId)!;
      clearTimeout(pending.timeoutId);
      
      if (type === 'error') {
        pending.reject(new Error(payload.message));
      } else {
        pending.resolve(payload);
      }
      
      this.pendingRequests.delete(requestId);
    }
    
    // Notification √† l'UI
    this.onMessageHandler?.(data);
  }
  
  sendMessage(type: string, payload: any, timeout = 30000): Promise<any> {
    return new Promise((resolve, reject) => {
      const requestId = crypto.randomUUID();
      
      if (!this.isReady || !this.port) {
        // Mettre en file d'attente si pas pr√™t
        this.messageQueue.push({ type, payload });
        reject(new Error("Worker not ready yet"));
        return;
      }
      
      // Timeout automatique
      const timeoutId = window.setTimeout(() => {
        this.pendingRequests.delete(requestId);
        reject(new Error(`Request ${requestId} timed out after ${timeout}ms`));
      }, timeout);
      
      this.pendingRequests.set(requestId, { resolve, reject, timeoutId });
      
      this.port.postMessage({ type, payload, requestId });
      console.log(`[UI Bridge] Message envoy√©: ${type} (${requestId})`);
    });
  }
  
  private flushMessageQueue() {
    while (this.messageQueue.length > 0) {
      const { type, payload } = this.messageQueue.shift()!;
      this.sendMessage(type, payload).catch(console.error);
    }
  }
  
  disconnect() {
    this.port?.close();
    this.isReady = false;
    console.log("[UI Bridge] D√©connect√©");
  }
}

export const kenshoBridge = new KenshoBridge();
Usage dans l'UI :
// Connexion
kenshoBridge.connect((data) => {
  if (data.type === 'final-response') {
    updateChatUI(data.payload.response);
  }
});

// Envoi avec Promise
try {
  const response = await kenshoBridge.sendMessage('process-prompt', { 
    prompt: 'Hello world' 
  });
  console.log("R√©ponse re√ßue:", response);
} catch (error) {
  console.error("Timeout ou erreur:", error);
}
5. üü° PROBL√àME : Pas de TypeSafety
Solution avec Types Partag√©s :
// src/core/types/messages.ts
export type KenshoMessage = 
  | { type: 'process-prompt'; payload: { prompt: string }; requestId: string }
  | { type: 'cancel-task'; payload: { taskId: string }; requestId: string }
  | { type: 'clear-cache'; payload: {}; requestId: string };

export type KenshoResponse = 
  | { type: 'final-response'; payload: { response: string }; requestId: string }
  | { type: 'error'; payload: { message: string; stack?: string }; requestId: string }
  | { type: 'processing-started'; requestId: string };

// Dans kernel.ts
handleMessage: async (message: KenshoMessage) => {
  switch (message.type) {
    case 'process-prompt':
      // TypeScript sait que message.payload.prompt existe ‚úÖ
      break;
    case 'cancel-task':
      // TypeScript sait que message.payload.taskId existe ‚úÖ
      break;
  }
}
üß™ Tests Recommand√©s
// Test 1 : Connexion basique
const bridge = new KenshoBridge();
bridge.connect((data) => console.log("Re√ßu:", data));

// Test 2 : Timeout
try {
  await bridge.sendMessage('process-prompt', { prompt: 'test' }, 100);
} catch (error) {
  console.assert(error.message.includes('timed out'));
}

// Test 3 : Validation de messages
port.postMessage({ invalidFormat: true }); // Doit √™tre rejet√©

// Test 4 : Multi-onglets
// Ouvrir 2 onglets et v√©rifier qu'ils partagent le worker
üèÜ Verdict Final
Note Actuelle : 6/10
‚úÖ Architecture conceptuelle excellente
‚úÖ SharedWorker bien utilis√©
‚ùå Aucune validation de messages (CRITIQUE)
‚ùå Gestion d'erreurs absente (CRITIQUE)
‚ùå Pas de cycle de vie
‚ùå Bridge trop simpliste
Note Avec Corrections : 9.5/10
Priorit√©s URGENTES :
CRITIQUE : Ajouter validation Zod
CRITIQUE : Impl√©menter try/catch partout
IMPORTANT : Syst√®me de requestId + timeout
IMPORTANT : Types stricts pour les messages