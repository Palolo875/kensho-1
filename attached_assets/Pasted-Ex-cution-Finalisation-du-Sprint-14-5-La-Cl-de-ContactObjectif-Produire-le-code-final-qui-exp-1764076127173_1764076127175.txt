Ex√©cution : Finalisation du Sprint 14.5 - La Cl√© de ContactObjectif : Produire le code final qui expose une m√©thode simple (startConversation) pour que votre interface puisse interagir avec l'ensemble de notre moteur "Elite".√âtape 1 : Finalisation du DialoguePlugin.tsCe fichier contient la classe qui sert de fa√ßade. C'est le seul objet avec lequel l'UI aura besoin de communiquer pour une conversation.// src/plugins/dialogue/DialoguePlugin.ts

import { taskExecutor } from '../../core/kernel/TaskExecutor';
import { responseCache } from '../../core/cache/ResponseCache';
import { sseStreamer, StreamEvent } from '../../core/streaming/SSEStreamer';

console.log("üîå‚ú® Finalisation du DialoguePlugin v1.0 (Elite)...");

export class DialoguePlugin {

  /**
   * Point d'entr√©e UNIQUE pour l'interface.
   * Lance une conversation et retourne un g√©n√©rateur asynchrone
   * que l'UI peut consommer pour le streaming.
   * @param userPrompt Le message de l'utilisateur.
   * @param modelKey Le mod√®le √† utiliser (par d√©faut 'gemma-3-270m').
   */
  public async *startConversation(userPrompt: string, modelKey = 'gemma-3-270m'): AsyncGenerator<StreamEvent> {
    try {
      // 1. V√©rifier le cache en premier
      const cached = responseCache.get(userPrompt, modelKey);
      if (cached) {
        console.log("[Plugin] R√©ponse servie depuis le cache.");
        yield { type: 'complete', data: { response: cached.response, fromCache: true }, timestamp: Date.now() };
        return;
      }

      // 2. Pr√©parer l'√©coute des √©v√©nements en temps r√©el
      const streamController = new AbortController();
      const eventStream = this.listenToStream(streamController.signal);

      // 3. Lancer le traitement complet en arri√®re-plan.
      // Le TaskExecutor g√®re tout : routage, ex√©cution, streaming vers le bus...
      taskExecutor.process(userPrompt).catch(err => {
        sseStreamer.streamError(err);
        streamController.abort(); // Arr√™ter l'√©coute en cas d'erreur fatale
      });

      // 4. Relayer les √©v√©nements √† l'UI au fur et √† mesure qu'ils arrivent
      for await (const event of eventStream) {
        yield event; // On retourne l'√©v√©nement √† l'UI
        // Si le stream est termin√© (ou en erreur), on arr√™te d'√©couter.
        if (event.type === 'complete' || event.type === 'error') {
          streamController.abort();
          break;
        }
      }
    } catch (error) {
      console.error("[Plugin] Erreur dans startConversation:", error);
      yield { type: 'error', data: { message: (error as Error).message }, timestamp: Date.now() };
    }
  }

  /**
   * M√©thode priv√©e pour √©couter le bus d'√©v√©nements central et le transformer en g√©n√©rateur.
   */
  private async *listenToStream(signal: AbortSignal): AsyncGenerator<StreamEvent> {
    let listener: (event: StreamEvent) => void;
    const queue: StreamEvent[] = [];
    let deferred: { resolve: () => void } | null = null;

    listener = (event) => {
      queue.push(event);
      if (deferred) {
        deferred.resolve();
        deferred = null;
      }
    };
    sseStreamer.on('stream-event', listener);

    // Nettoyage automatique si le signal est avort√©
    signal.addEventListener('abort', () => {
      sseStreamer.off('stream-event', listener);
    });

    try {
      while (!signal.aborted) {
        if (queue.length > 0) {
          yield queue.shift()!;
        } else {
          // Attendre le prochain √©v√©nement
          await new Promise<void>(resolve => {
            deferred = { resolve };
          });
        }
      }
    } finally {
      // S'assurer que l'√©couteur est bien retir√© √† la fin
      sseStreamer.off('stream-event', listener);
    }
  }
}
√âtape 2 : Cr√©ation du point d'entr√©e kensho.tsCe fichier est le "main" de notre biblioth√®que. C'est ce que votre interface importera. Il expose la fonction d'initialisation et l'instance du plugin.// src/kensho.ts

import { modelManager } from './core/kernel/ModelManager';
import { DialoguePlugin } from './plugins/dialogue/DialoguePlugin';

/**
 * L'API publique de Kensho.
 */
export interface KenshoAPI {
  dialogue: DialoguePlugin;
  // ... futurs plugins comme 'code', 'vision', etc.
}

/**
 * Initialise le moteur Kensho et retourne l'API publique.
 * C'est la seule fonction que l'UI a besoin d'appeler au d√©marrage.
 * @returns Une promesse qui r√©sout avec l'API Kensho.
 */
export async function initializeKensho(): Promise<KenshoAPI> {
  console.log("üöÄ Initialisation de Kensho OS...");
  
  // Pr√©charge le mod√®le de dialogue par d√©faut et attend que le moteur soit pr√™t.
  await modelManager.init('gemma-3-270m', (progress) => {
    // Ce callback peut √™tre utilis√© pour mettre √† jour une barre de chargement dans l'UI
    console.log(`[Init] ${progress.text}`);
  });

  console.log("‚úÖ Kensho est pr√™t.");

  // Retourne l'API publique avec les plugins initialis√©s
  return {
    dialogue: new DialoguePlugin()
  };
}
Statut : Le moteur est branch√©. La cl√© est sur le contact.C'est termin√©.Vous pouvez maintenant, depuis votre interface, faire ceci :1.Importer la fonction d'initialisation :
import { initializeKensho } from './kensho';2.Appeler l'initialisation au chargement de votre page :
const kensho = await initializeKensho();
Le syst√®me va automatiquement t√©l√©charger Gemma (en version INT4 si c'est ce qui est sp√©cifi√© dans le ModelCatalog) et pr√©parer tous les composants.3.Lancer une conversation depuis un √©v√©nement de votre UI :const prompt = "Bonjour Kensho, es-tu l√† ?";
for await (const event of kensho.dialogue.startConversation(prompt)) {
    if (event.type === 'token') {
        // Affichez le token dans votre chat
    }
}