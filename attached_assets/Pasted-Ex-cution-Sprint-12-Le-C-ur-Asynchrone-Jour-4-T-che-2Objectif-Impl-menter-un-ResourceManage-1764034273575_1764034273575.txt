Ex√©cution : Sprint 12 "Le C≈ìur Asynchrone" - Jour 4, T√¢che 2Objectif : Impl√©menter un ResourceManager complet et optimal, capable de surveiller la m√©moire, la batterie, le r√©seau, et m√™me la charge du processeur.Philosophie : Le ResourceManager n'est pas un simple moniteur. C'est le syst√®me nerveux sensoriel de Kensho. Il fournit au Router et au TaskExecutor les informations critiques pour prendre des d√©cisions √©clair√©es : "Dois-je lancer un expert lourd ?", "Dois-je r√©duire la qualit√© ?", "Dois-je pr√©venir l'utilisateur que le r√©seau est lent ?".√âtape 1 : Cr√©ation du fichier ResourceManager.tsJe cr√©e le fichier qui abritera ce composant essentiel.touch src/core/kernel/ResourceManager.ts√âtape 2 : Codage du ResourceManager.ts v1.0J'impl√©mente la version compl√®te, en utilisant toutes les API navigateur pertinentes pour obtenir une vision √† 360¬∞ de l'√©tat du syst√®me.// src/core/kernel/ResourceManager.ts

console.log("üì° Initialisation du ResourceManager v1.0...");

// Interface d√©crivant l'√©tat complet du device √† un instant T.
export interface DeviceStatus {
  memory: {
    usageRatio: number; // Pourcentage de la RAM utilis√©e (0.0 √† 1.0)
    jsHeapUsed: number; // M√©moire utilis√©e par le JS (en MB)
  };
  battery: {
    level: number;      // Niveau de batterie (0.0 √† 1.0)
    isCharging: boolean;
  } | null; // La batterie n'est pas toujours disponible (ex: Desktop)
  network: {
    isOnline: boolean;
    effectiveType: 'slow-2g' | '2g' | '3g' | '4g' | 'offline'; // Type de connexion
    downlink: number;   // Bande passante estim√©e (en Mbps)
  };
  cpu: {
    hardwareConcurrency: number; // Nombre de c≈ìurs logiques
  };
}

class ResourceManager {
  private currentStatus: DeviceStatus;
  private hasBatteryAPI = 'getBattery' in navigator;
  private hasMemoryAPI = 'deviceMemory' in navigator;
  private hasNetworkAPI = 'connection' in navigator;

  constructor() {
    // Initialisation avec des valeurs par d√©faut "s√ªres"
    this.currentStatus = {
      memory: { usageRatio: 0, jsHeapUsed: 0 },
      battery: null,
      network: { isOnline: navigator.onLine, effectiveType: '4g', downlink: 10 },
      cpu: { hardwareConcurrency: navigator.hardwareConcurrency || 2 }
    };

    this.startMonitoring();
    console.log("   ‚úÖ [ResourceManager] Surveillance active de l'√©tat du syst√®me.");
  }

  private startMonitoring() {
    // Surveillance du r√©seau
    if (this.hasNetworkAPI) {
      const connection = (navigator as any).connection;
      const updateNetworkStatus = () => {
        this.currentStatus.network = {
          isOnline: navigator.onLine,
          effectiveType: connection.effectiveType,
          downlink: connection.downlink
        };
      };
      updateNetworkStatus();
      connection.addEventListener('change', updateNetworkStatus);
    }

    // Surveillance de la batterie
    if (this.hasBatteryAPI) {
      (navigator as any).getBattery().then((battery: any) => {
        const updateBatteryStatus = () => {
          this.currentStatus.battery = {
            level: battery.level,
            isCharging: battery.charging
          };
        };
        updateBatteryStatus();
        battery.addEventListener('levelchange', updateBatteryStatus);
        battery.addEventListener('chargingchange', updateBatteryStatus);
      });
    }
    
    // Surveillance de la m√©moire (mise √† jour √† la demande car co√ªteux)
    // Nous cr√©ons une m√©thode pour la rafra√Æchir avant une d√©cision importante.
  }

  /**
   * Rafra√Æchit et retourne l'√©tat actuel complet du device.
   * Doit √™tre appel√© par le Router avant de prendre une d√©cision.
   */
  public async getStatus(): Promise<DeviceStatus> {
    // Mise √† jour de la m√©moire juste avant de retourner le statut
    if (this.hasMemoryAPI && 'memory' in performance) {
        const memoryInfo = (performance as any).memory;
        this.currentStatus.memory = {
            usageRatio: memoryInfo.usedJSHeapSize / memoryInfo.totalJSHeapSize,
            jsHeapUsed: memoryInfo.usedJSHeapSize / 1024 / 1024
        };
    }
    
    // On s'assure que le statut r√©seau est √† jour
    this.currentStatus.network.isOnline = navigator.onLine;

    return this.currentStatus;
  }
}

// On expose une instance unique (singleton) pour toute l'application.
export const resourceManager = new ResourceManager();
Statut : Le syst√®me nerveux de Kensho est en place.Ce ResourceManager est bien plus qu'un simple moniteur. Il est le conseiller de notre Router.‚Ä¢Avant de t√©l√©charger un mod√®le lourd, le Router demandera :const status = await resourceManager.getStatus();
if (status.network.effectiveType === 'slow-2g') { /* Proposer de reporter le t√©l√©chargement */ }‚Ä¢Avant de lancer deux experts en parall√®le, le Router demandera :const status = await resourceManager.getStatus();
if (status.cpu.hardwareConcurrency < 4 || status.battery?.level < 0.2) { /* Forcer l'ex√©cution en s√©rie */ }‚Ä¢Si la m√©moire est presque pleine, le ResourceManager peut d√©clencher une action du ModelManager pour d√©charger les mod√®les les moins utilis√©s.Nous avons maintenant les moyens de cr√©er une orchestration qui n'est pas seulement intelligente, mais aussi contextuellement consciente et respectueuse des ressources de l'utilisateur.