Ex√©cution : Sprint 1B-Core - T√¢che des Jours 1-2 (Validation)
Objectif : Valider le WorkerRegistry avec un test d'int√©gration qui simule le cycle de vie des agents (d√©marrage, activit√©, arr√™t).
Philosophie : Un test d'int√©gration pour un syst√®me distribu√© doit √™tre aussi proche que possible de la r√©alit√©. Nous allons utiliser de vrais workers et tester non seulement le r√©sultat final, mais aussi le comportement temporel (la suppression des agents inactifs).
Impl√©mentation du Test d'Int√©gration du WorkerRegistry
1. Pr√©paration :
Nous avons besoin d'un agent de test tr√®s simple. Notre PingAgent est parfait, mais nous allons nous assurer qu'il est bien configur√© pour le test.

    Action : V√©rifier que npm run build:test-agents est √† jour et qu'il g√©n√®re bien dist/test-agents/ping.agent.js.

2. Cr√©ation du Fichier de Test sprint1b-registry-e2e.html :
Bash

touch tests/browser/sprint1b-registry-e2e.html

3. Code Complet du Fichier de Test :
Ce test est plus complexe que le pr√©c√©dent. Il va orchestrer le d√©marrage et l'arr√™t de workers et interroger leur √©tat interne pour valider le registre.
HTML

<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Kensho - Sprint 1B - Test E2E du WorkerRegistry</title>
    <style>
        /* ... (m√™me style que le test pr√©c√©dent) ... */
        body { font-family: system-ui, sans-serif; line-height: 1.6; padding: 2em; background-color: #1e1e1e; color: #d4d4d4; }
        pre { background-color: #282c34; padding: 1em; border-radius: 8px; white-space: pre-wrap; font-family: 'Courier New', Courier, monospace; }
        button { font-size: 1.2em; padding: 0.5em 1em; cursor: pointer; border-radius: 5px; border: 1px solid #61afef; background-color: #282c34; color: #61afef; }
        h1, h2 { color: #61afef; }
        .pass { color: #98c379; font-weight: bold; }
        .fail { color: #e06c75; font-weight: bold; }
        .info { color: #56b6c2; }
        .summary { margin-top: 1em; border-top: 1px solid #444; padding-top: 1em; }
    </style>
</head>
<body>
    <h1>Sprint 1B - Test E2E du WorkerRegistry</h1>
    <p>Ce test valide que les agents se d√©couvrent mutuellement et que les agents inactifs sont correctement retir√©s du registre.</p>
    <button id="run-tests">Lancer les Tests</button>
    <h2>R√©sultats :</h2>
    <pre id="results"></pre>

    <script type="module">
        const resultsEl = document.getElementById('results');
        const log = (message, status = 'info') => {
            const line = document.createElement('div');
            line.innerHTML = `<span class="${status}">[${status.toUpperCase()}] ${message}</span>`;
            resultsEl.appendChild(line);
            console.log(`[${status.toUpperCase()}] ${message}`);
        };

        // Helper pour attendre un certain temps
        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        // Helper pour d√©marrer un worker et attendre son signal READY
        function startWorker(name, path) {
            const worker = new Worker(path);
            const readyPromise = new Promise((resolve, reject) => {
                const timeoutId = setTimeout(() => reject(new Error(`Worker ${name} n'a pas d√©marr√© √† temps.`)), 5000);
                worker.onmessage = (e) => {
                    if (e.data && e.data.type === 'READY') {
                        clearTimeout(timeoutId);
                        worker.onmessage = null;
                        resolve(worker);
                    }
                };
            });
            return readyPromise;
        }

        document.getElementById('run-tests').addEventListener('click', async () => {
            resultsEl.innerHTML = '';
            log('--- D√©marrage du test du WorkerRegistry ---', 'info');

            const { MessageBus } = await import('/src/core/communication/MessageBus.ts');
            const mainBus = new MessageBus('MainThread');
            let workers = {};
            let testPassed = true;

            try {
                // --- √âtape 1: D√©marrage et D√©couverte ---
                log('\n[√âtape 1] D√©marrage de 3 agents et v√©rification de la d√©couverte mutuelle...', 'info');
                
                const workerNames = ['AgentA', 'AgentB', 'AgentC'];
                const workerPromises = workerNames.map(name => startWorker(name, '/dist/test-agents/ping.agent.js'));
                
                const startedWorkers = await Promise.all(workerPromises);
                workerNames.forEach((name, i) => workers[name] = startedWorkers[i]);
                log('  Tous les agents ont d√©marr√©.', 'pass');

                // Laisser un peu de temps pour que les annonces se propagent
                await sleep(500);

                // Interroger chaque worker pour conna√Ætre son registre
                for (const name of workerNames) {
                    const activeList = await mainBus.request(name, { method: 'getActiveWorkers', args: [] });
                    log(`  Registre de ${name}: [${activeList.sort().join(', ')}]`, 'info');
                    
                    // Chaque worker doit conna√Ætre tous les autres
                    if (activeList.length === workerNames.length && workerNames.every(n => activeList.includes(n))) {
                        log(`  -> Le registre de ${name} est correct.`, 'pass');
                    } else {
                        log(`  -> ERREUR: Le registre de ${name} est incorrect.`, 'fail');
                        testPassed = false;
                    }
                }

                if (!testPassed) throw new Error("La phase de d√©couverte a √©chou√©.");

                // --- √âtape 2: Arr√™t d'un agent et v√©rification du nettoyage ---
                log('\n[√âtape 2] Arr√™t de l\'AgentB et v√©rification du nettoyage du registre...', 'info');
                
                workers['AgentB'].terminate();
                log('  AgentB termin√©.', 'info');

                // Attendre plus longtemps que le INACTIVITY_THRESHOLD (10s) + le cleanupInterval (5s)
                const waitTime = 16000;
                log(`  Attente de ${waitTime / 1000} secondes pour le garbage collector...`, 'info');
                await sleep(waitTime);

                const remainingWorkers = ['AgentA', 'AgentC'];
                for (const name of remainingWorkers) {
                    const activeList = await mainBus.request(name, { method: 'getActiveWorkers', args: [] });
                    log(`  Registre de ${name}: [${activeList.sort().join(', ')}]`, 'info');

                    // Le registre ne doit plus contenir AgentB
                    if (activeList.length === remainingWorkers.length && !activeList.includes('AgentB')) {
                        log(`  -> Le registre de ${name} a √©t√© nettoy√© correctement.`, 'pass');
                    } else {
                        log(`  -> ERREUR: Le registre de ${name} n'a pas √©t√© nettoy√©.`, 'fail');
                        testPassed = false;
                    }
                }

            } catch (error) {
                log(`Erreur critique durant le test: ${error.message}`, 'fail');
                testPassed = false;
            } finally {
                // Nettoyage final
                Object.values(workers).forEach(w => w.terminate());
                mainBus.dispose();
                log('\n--- Test Termin√© ---', 'summary');
                if (testPassed) {
                    log('üéâ T√¢che "WorkerRegistry" valid√©e avec succ√®s !', 'pass');
                } else {
                    log('‚ùóÔ∏è Des probl√®mes ont √©t√© d√©tect√©s dans le WorkerRegistry.', 'fail');
                }
            }
        });
    </script>
</body>
</html>

    Note : Pour que ce test fonctionne, nous devons exposer la m√©thode getActiveWorkers de l'AgentRuntime.

3. Ajout de la M√©thode de Test √† AgentRuntime :
TypeScript

// src/core/agent-system/AgentRuntime.ts
// ...
export class AgentRuntime {
    // ...
    constructor(name: WorkerName) {
        // ...
        // NOUVEAU : Enregistrer une m√©thode interne pour le d√©bogage
        this.registerMethod('getActiveWorkers', () => this.getActiveWorkers());
    }
    // ...
    public getActiveWorkers(): WorkerName[] {
        return this.workerRegistry.getActiveWorkers();
    }
    // ...
}

Conclusion de la T√¢che
Processus de Validation :

    Ex√©cuter npm run build:test-agents pour s'assurer que la derni√®re version de nos agents (avec le handshake READY et la m√©thode de test) est build√©e.
    Lancer le serveur de dev.
    Ouvrir tests/browser/sprint1b-registry-e2e.html.
    Cliquer sur "Lancer les Tests".

Crit√®re de Succ√®s :
La page doit afficher un succ√®s pour les deux √©tapes, se terminant par :
üéâ T√¢che "WorkerRegistry" valid√©e avec succ√®s !
Avec ce r√©sultat, nous avons une confiance extr√™mement √©lev√©e dans notre capacit√© √† maintenir une vue coh√©rente de la constellation. C'est la fin de la t√¢che des Jours 1-2.
Nous sommes maintenant pr√™ts √† construire par-dessus cette fondation en passant √† la T√¢che des Jours 3-5 : L'√âlection de Leader (LeaderElection).