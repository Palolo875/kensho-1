Exécution : Sprint 1B-Core - Tâche des Jours 3-5
Objectif : Implémenter le LeaderElection
Philosophie : Nous implémentons une version "Lazy Bully" de l'algorithme, optimisée pour réduire le trafic réseau, et nous intégrons l'epochId dès le départ pour une robustesse maximale contre les "split-brains".
Sous-Étape 1 : Conception et Squelette du Code
1. Modification des Types :
Nous avons besoin de messages spécifiques à l'élection.
TypeScript

// src/core/communication/types/index.ts
// ...

// Un message ELECTION est envoyé pour démarrer un vote.
export interface ElectionPayload {
  candidateId: WorkerName;
}

// Un message ALIVE est une réponse à un message ELECTION.
export interface AlivePayload {
  responderId: WorkerName;
}

// Un message NEW_LEADER est diffusé par le nouveau leader.
export interface NewLeaderPayload {
  leaderId: WorkerName;
  epochId: number;
}

2. Création du Fichier LeaderElection.ts :
Bash

touch src/core/guardian/LeaderElection.ts

3. Squelette du Code LeaderElection.ts :
TypeScript

// src/core/guardian/LeaderElection.ts
import { WorkerName } from '../communication/types';
import { MessageBus } from '../communication/MessageBus';
import { WorkerRegistry } from './WorkerRegistry';

/**
 * Gère le processus d'élection de leader pour un agent.
 * Implémente un algorithme "Lazy Bully" avec gestion d'epoch.
 */
export class LeaderElection {
    private readonly selfName: WorkerName;
    private readonly messageBus: MessageBus;
    private readonly workerRegistry: WorkerRegistry;

    private isElectionRunning = false;
    private receivedAlive = false;

    constructor(selfName: WorkerName, messageBus: MessageBus, workerRegistry: WorkerRegistry) {
        this.selfName = selfName;
        this.messageBus = messageBus;
        this.workerRegistry = workerRegistry;
    }

    /**
     * Déclenche une nouvelle élection.
     */
    public startElection(): void {
        // Logique à implémenter
    }

    /**
     * Gère la réception d'un message ELECTION d'un autre worker.
     */
    public handleElectionMessage(candidateId: WorkerName): void {
        // Logique à implémenter
    }

    /**
     * Gère la réception d'un message ALIVE d'un worker de plus haut rang.
     */
    public handleAliveMessage(): void {
        // Logique à implémenter
    }
}

Sous-Étape 2 : Implémentation de la Logique du LeaderElection
Voici le code complet et commenté pour src/core/guardian/LeaderElection.ts.
TypeScript

// src/core/guardian/LeaderElection.ts
import { WorkerName } from '../communication/types';
import { MessageBus } from '../communication/MessageBus';
import { WorkerRegistry } from './WorkerRegistry';

/**
 * Gère le processus d'élection de leader pour un agent.
 * Implémente un algorithme "Lazy Bully" avec gestion d'epoch.
 */
export class LeaderElection {
    private readonly selfName: WorkerName;
    private readonly messageBus: MessageBus;
    private readonly workerRegistry: WorkerRegistry;

    private isElectionRunning = false;
    private receivedAliveInCurrentRound = false;
    private electionTimeout: any;

    // Délai avant de se considérer comme leader si personne ne répond.
    private static readonly ELECTION_TIMEOUT = 1000; // 1 seconde

    constructor(selfName: WorkerName, messageBus: MessageBus, workerRegistry: WorkerRegistry) {
        this.selfName = selfName;
        this.messageBus = messageBus;
        this.workerRegistry = workerRegistry;
    }

    /**
     * Déclenche une nouvelle élection.
     */
    public startElection(): void {
        if (this.isElectionRunning) {
            return; // Une élection est déjà en cours.
        }
        console.log(`[${this.selfName}] Déclenchement d'une élection.`);
        this.isElectionRunning = true;
        this.receivedAliveInCurrentRound = false;

        const higherWorkers = this.workerRegistry.getActiveWorkers()
            .filter(name => name > this.selfName);

        // Si je suis le worker avec l'ID le plus élevé, je deviens leader immédiatement.
        if (higherWorkers.length === 0) {
            this.becomeLeader();
            return;
        }

        // Envoyer un message ELECTION uniquement aux workers de plus haut rang.
        higherWorkers.forEach(workerName => {
            this.messageBus.send(workerName, { systemType: 'ELECTION', candidateId: this.selfName });
        });

        // Démarrer un timer. Si aucun worker de plus haut rang ne répond "ALIVE" à temps, je deviens leader.
        this.electionTimeout = setTimeout(() => {
            if (!this.receivedAliveInCurrentRound) {
                this.becomeLeader();
            } else {
                // Un autre worker a pris la main, l'élection est terminée pour moi.
                this.isElectionRunning = false;
            }
        }, LeaderElection.ELECTION_TIMEOUT);
    }

    /**
     * Gère la réception d'un message ELECTION d'un worker de plus bas rang.
     */
    public handleElectionMessage(candidateId: WorkerName): void {
        // Si le message vient d'un worker avec un ID plus bas, je lui réponds "ALIVE"
        // pour lui dire d'arrêter son élection, et je démarre la mienne.
        if (this.selfName > candidateId) {
            this.messageBus.send(candidateId, { systemType: 'ALIVE', responderId: this.selfName });
            this.startElection();
        }
    }

    /**
     * Gère la réception d'un message ALIVE d'un worker de plus haut rang.
     */
    public handleAliveMessage(): void {
        // Si je reçois un ALIVE, cela signifie qu'un worker de plus haut rang est actif
        // et va prendre en charge l'élection. J'arrête mon propre processus.
        this.receivedAliveInCurrentRound = true;
        clearTimeout(this.electionTimeout);
        this.isElectionRunning = false;
        console.log(`[${this.selfName}] Élection annulée, un worker de plus haut rang est actif.`);
    }

    /**
     * Se déclare leader et l'annonce à toute la constellation.
     */
    private becomeLeader(): void {
        console.log(`[${this.selfName}] Je suis le nouveau Leader !`);
        this.isElectionRunning = false;
        
        // La logique de l'epochId sera gérée par le Guardian principal.
        // Ici, on se contente de diffuser l'annonce.
        this.messageBus.broadcastSystemMessage('NEW_LEADER', { leaderId: this.selfName });
    }
}

Sous-Étape 3 : Intégration dans un OrionGuardian de base
Nous avons besoin d'un chef d'orchestre pour utiliser cette logique. Nous créons une première version du OrionGuardian.
1. Création du Fichier OrionGuardian.ts :
Bash

touch src/core/guardian/OrionGuardian.ts

2. Implémentation du OrionGuardian.ts :
TypeScript

// src/core/guardian/OrionGuardian.ts
import { WorkerName, KenshoMessage } from '../communication/types';
import { MessageBus } from '../communication/MessageBus';
import { WorkerRegistry } from './WorkerRegistry';
import { LeaderElection } from './LeaderElection';

/**
 * Le Guardian est le cerveau reptilien de chaque agent.
 * Il gère la conscience de la constellation (via le Registry) et la
 * structure de commandement (via l'Élection).
 */
export class OrionGuardian {
    private readonly selfName: WorkerName;
    private readonly messageBus: MessageBus;
    public readonly workerRegistry: WorkerRegistry;
    private readonly leaderElection: LeaderElection;

    private currentLeader: WorkerName | null = null;
    private currentEpoch = 0;

    constructor(selfName: WorkerName, messageBus: MessageBus) {
        this.selfName = selfName;
        this.messageBus = messageBus;
        this.workerRegistry = new WorkerRegistry(selfName);
        this.leaderElection = new LeaderElection(selfName, messageBus, this.workerRegistry);

        this.messageBus.subscribeToSystemMessages(this.handleSystemMessage.bind(this));
    }

    private handleSystemMessage(message: KenshoMessage): void {
        // Mettre à jour le registre avec chaque message
        this.workerRegistry.update(message.sourceWorker);

        if (message.payload.systemType) {
            switch (message.payload.systemType) {
                case 'ELECTION':
                    this.leaderElection.handleElectionMessage(message.payload.candidateId);
                    break;
                case 'ALIVE':
                    this.leaderElection.handleAliveMessage();
                    break;
                case 'NEW_LEADER':
                    // Mettre à jour le leader et l'epoch
                    this.currentLeader = message.payload.leaderId;
                    this.currentEpoch = (this.currentEpoch || 0) + 1; // Simplifié pour l'instant
                    console.log(`[${this.selfName}] Nouveau leader reconnu: ${this.currentLeader} (Epoch: ${this.currentEpoch})`);
                    break;
            }
        }
    }

    public start(): void {
        // Au démarrage, chaque agent tente de lancer une élection.
        // L'algorithme Bully s'assurera qu'un seul leader émerge.
        setTimeout(() => this.leaderElection.startElection(), 1000 + Math.random() * 1000);
    }
    
    // Méthodes pour les tests et l'Observatory
    public getStatus() {
        return {
            isLeader: this.currentLeader === this.selfName,
            leader: this.currentLeader,
            epoch: this.currentEpoch,
            activeWorkers: this.workerRegistry.getActiveWorkers(),
        };
    }
}

3. Mise à Jour de l'Intégration dans AgentRuntime :
TypeScript

// src/core/agent-system/AgentRuntime.ts
import { OrionGuardian } from '../guardian/OrionGuardian'; // Importer le Guardian

export class AgentRuntime {
    // ...
    private readonly guardian: OrionGuardian; // Ajouter une instance du Guardian

    constructor(name: WorkerName) {
        this.agentName = name;
        this.messageBus = new MessageBus(name);
        this.guardian = new OrionGuardian(name, this.messageBus); // Initialiser le Guardian

        this.messageBus.setRequestHandler(this.handleRequest.bind(this));
        
        // Annoncer son existence (déplacé dans le Guardian)
        this.guardian.start();
    }

    // ...
    // Exposer les méthodes du Guardian pour les tests
    public getGuardianStatus() {
        return this.guardian.getStatus();
    }
    // ...
}

Conclusion de la Tâche
Nous avons maintenant une implémentation fonctionnelle de l'élection de leader.

    Ce qui est fait :
        Un algorithme "Lazy Bully" qui réduit le trafic réseau.
        Un OrionGuardian qui orchestre le WorkerRegistry et le LeaderElection.
        L'intégration de ce Guardian dans chaque AgentRuntime.
    Ce qui est intentionnellement omis (pour les tâches suivantes) :
        La détection de panne par Heartbeat.
        Le Jittered Exponential Backoff (sera ajouté avec la détection de panne).
        L'affichage dans l'Observatory.
