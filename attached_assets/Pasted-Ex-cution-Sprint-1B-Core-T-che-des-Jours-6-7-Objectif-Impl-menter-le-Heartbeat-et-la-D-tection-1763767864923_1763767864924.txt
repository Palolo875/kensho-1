Ex√©cution : Sprint 1B-Core - T√¢che des Jours 6-7
Objectif : Impl√©menter le Heartbeat et la D√©tection de Panne
Philosophie : La survie du syst√®me d√©pend de sa capacit√© √† d√©tecter rapidement et de mani√®re fiable la perte de son leader. Nous allons impl√©menter un m√©canisme de "dead man's switch" : si le leader arr√™te d'envoyer son "pouls", les followers initient un coup d'√âtat.
Sous-√âtape 1 : Impl√©mentation de la Logique de Heartbeat
1. Mise √† Jour du OrionGuardian.ts :
C'est le Guardian qui est responsable de la gestion du cycle de vie du heartbeat.
TypeScript

// src/core/guardian/OrionGuardian.ts
// ... (imports)

export class OrionGuardian {
    // ... (propri√©t√©s existantes)
    private heartbeatTimer: any;
    private failureDetectorTimer: any;

    private static readonly HEARTBEAT_INTERVAL = 2000; // 2 secondes
    private static readonly FAILURE_THRESHOLD = 6000;  // 6 secondes (3x l'intervalle)

    constructor(selfName: WorkerName, messageBus: MessageBus) {
        // ... (constructeur existant)
    }

    private handleSystemMessage(message: KenshoMessage): void {
        this.workerRegistry.update(message.sourceWorker);

        if (message.payload.systemType) {
            switch (message.payload.systemType) {
                // ... (cas ELECTION, ALIVE)
                case 'NEW_LEADER':
                    this.handleNewLeader(message.payload.leaderId);
                    break;
                case 'HEARTBEAT':
                    // Si on re√ßoit un heartbeat, on r√©initialise notre d√©tecteur de panne.
                    if (message.sourceWorker === this.currentLeader) {
                        this.resetFailureDetector();
                    }
                    break;
            }
        }
    }

    private handleNewLeader(leaderId: WorkerName): void {
        if (leaderId === this.currentLeader) return; // Pas de changement

        console.log(`[${this.selfName}] Nouveau leader reconnu: ${leaderId}`);
        this.currentLeader = leaderId;
        this.currentEpoch++; // Chaque changement de leader incr√©mente l'epoch

        // Arr√™ter tous les timers pr√©c√©dents
        clearInterval(this.heartbeatTimer);
        clearTimeout(this.failureDetectorTimer);

        if (this.isSelfLeader()) {
            // Si JE suis le nouveau leader, je commence √† envoyer mon pouls.
            this.startHeartbeat();
        } else {
            // Si je suis un follower, je commence √† √©couter le pouls du leader.
            this.startFailureDetector();
        }
    }

    /**
     * D√©marre l'envoi p√©riodique de heartbeats. Uniquement pour le leader.
     */
    private startHeartbeat(): void {
        console.log(`[${this.selfName}] Leader: D√©marrage de l'envoi des heartbeats.`);
        this.heartbeatTimer = setInterval(() => {
            this.messageBus.broadcastSystemMessage('HEARTBEAT', { epochId: this.currentEpoch });
        }, OrionGuardian.HEARTBEAT_INTERVAL);
    }

    /**
     * D√©marre le timer qui d√©clenchera une √©lection si le leader est silencieux.
     */
    private startFailureDetector(): void {
        console.log(`[${this.selfName}] Follower: D√©marrage du d√©tecteur de panne pour le leader ${this.currentLeader}.`);
        this.failureDetectorTimer = setTimeout(() => {
            console.log(`[${this.selfName}] Le leader ${this.currentLeader} est silencieux ! D√©clenchement d'une nouvelle √©lection.`);
            this.currentLeader = null; // Le leader est consid√©r√© comme mort.
            this.leaderElection.startElection();
        }, OrionGuardian.FAILURE_THRESHOLD);
    }

    /**
     * R√©initialise le timer du d√©tecteur de panne. Appel√© √† chaque heartbeat re√ßu.
     */
    private resetFailureDetector(): void {
        clearTimeout(this.failureDetectorTimer);
        this.startFailureDetector();
    }

    public isSelfLeader(): boolean {
        return this.selfName === this.currentLeader;
    }

    public start(): void {
        // ... (inchang√©)
    }
    
    public getStatus() {
        // ... (inchang√©)
    }
}

2. Mise √† Jour de LeaderElection.ts :
La m√©thode becomeLeader doit maintenant appeler le Guardian pour qu'il g√®re le changement d'√©tat.
TypeScript

// src/core/guardian/LeaderElection.ts
// ...

export class LeaderElection {
    // ...
    private becomeLeader(): void {
        if (this.isElectionRunning) {
            console.log(`[${this.selfName}] √âlection gagn√©e. Je deviens le nouveau Leader !`);
            this.isElectionRunning = false;
            
            // On ne diffuse plus directement, on notifie le Guardian qui g√®re l'√©tat.
            this.messageBus.send(this.selfName, { systemType: 'I_AM_THE_NEW_LEADER' });
        }
    }
}

// src/core/guardian/OrionGuardian.ts
// ...
    private handleSystemMessage(message: KenshoMessage): void {
        // ...
        // NOUVEAU cas pour g√©rer la notification interne
        if (message.payload.systemType === 'I_AM_THE_NEW_LEADER' && message.sourceWorker === this.selfName) {
            this.handleNewLeader(this.selfName);
            // Annoncer le leadership √† tous les autres
            this.messageBus.broadcastSystemMessage('NEW_LEADER', { leaderId: this.selfName });
            return;
        }
        // ...
    }
// ...

    Commentaire : Cette refactorisation est importante. Le LeaderElection est responsable de l'algorithme d'√©lection, mais c'est le Guardian qui est le "state manager" du statut de leader. Cela respecte le Principe de Responsabilit√© Unique.

Sous-√âtape 2 : Validation avec un Test de Bout en Bout
Objectif : Cr√©er un test qui simule la panne du leader et v√©rifie qu'une nouvelle √©lection est bien d√©clench√©e. C'est la "D√©mo du Cerveau R√©silient".
1. Cr√©ation du Fichier de Test sprint1b-resilience-e2e.html :
Bash

touch tests/browser/sprint1b-resilience-e2e.html

2. Code Complet du Fichier de Test :
Ce test est une version am√©lior√©e du pr√©c√©dent. Il va d√©marrer des agents, attendre qu'un leader soit √©lu, le "tuer", puis v√©rifier qu'un nouveau leader √©merge.
HTML

<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Kensho - Sprint 1B - Test E2E de R√©silience</title>
    <style>/* ... (m√™me style) ... */</style>
</head>
<body>
    <h1>Sprint 1B - Test E2E de R√©silience (Heartbeat & Panne)</h1>
    <p>Ce test valide que la constellation peut survivre √† la perte de son leader.</p>
    <button id="run-tests">Lancer le Test de R√©silience</button>
    <h2>R√©sultats :</h2>
    <pre id="results"></pre>

    <script type="module">
        const resultsEl = document.getElementById('results');
        const log = (message, status = 'info') => { /* ... (m√™me fonction log) ... */ };
        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
        const startWorker = (path) => { /* ... (m√™me fonction startWorker) ... */ };

        document.getElementById('run-tests').addEventListener('click', async () => {
            resultsEl.innerHTML = '';
            log('--- D√©marrage du test de r√©silience ---', 'info');

            const { MessageBus } = await import('/src/core/communication/MessageBus.ts');
            const mainBus = new MessageBus('MainThread');
            let workers = {};
            let testPassed = true;

            try {
                // --- √âtape 1: √âlection initiale ---
                const agentNames = ['AgentA', 'AgentB', 'AgentC'];
                const initialExpectedLeader = 'AgentC';
                log(`[√âtape 1] D√©marrage de ${agentNames.length} agents. Leader initial attendu: '${initialExpectedLeader}'.`);

                const startedWorkers = await Promise.all(agentNames.map(name => startWorker('/dist/test-agents/ping.agent.js')));
                agentNames.forEach((name, i) => workers[name] = { worker: startedWorkers[i], name });
                log('  Agents pr√™ts.', 'pass');

                await sleep(3000); // Attendre la fin de la premi√®re √©lection

                const statuses1 = await Promise.all(agentNames.map(name => mainBus.request(name, { method: 'getGuardianStatus', args: [] })));
                const firstLeader = statuses1[0].leader;
                if (firstLeader !== initialExpectedLeader) {
                    throw new Error(`L'√©lection initiale a √©chou√©. Leader √©lu: ${firstLeader}`);
                }
                log(`  √âlection initiale r√©ussie. Leader est bien '${firstLeader}'.`, 'pass');

                // --- √âtape 2: Panne du Leader ---
                log(`\n[√âtape 2] Simulation de la panne du leader '${firstLeader}'...`, 'info');
                workers[firstLeader].worker.terminate();
                delete workers[firstLeader];
                const remainingAgentNames = Object.keys(workers);
                const newExpectedLeader = 'AgentB';
                log(`  '${firstLeader}' termin√©. Agents restants: [${remainingAgentNames.join(', ')}]. Nouveau leader attendu: '${newExpectedLeader}'.`);

                // --- √âtape 3: Nouvelle √âlection et V√©rification ---
                // Attendre le seuil de d√©tection de panne (6s) + le temps d'√©lection (3s)
                const reElectionTime = 9000;
                log(`[√âtape 3] Attente de ${reElectionTime / 1000}s pour la d√©tection de panne et la nouvelle √©lection...`, 'info');
                await sleep(reElectionTime);

                const statuses2 = await Promise.all(remainingAgentNames.map(name => mainBus.request(name, { method: 'getGuardianStatus', args: [] })));
                
                let consensusFailed = false;
                const secondLeader = statuses2[0].leader;
                statuses2.forEach(status => {
                    if (status.leader !== secondLeader) consensusFailed = true;
                });

                if (consensusFailed) {
                    throw new Error("Les agents ne sont pas d'accord sur le nouveau leader !");
                }
                log('  Consensus atteint sur le nouveau leader.', 'pass');

                if (secondLeader === newExpectedLeader) {
                    log(`  Nouvelle √©lection r√©ussie. Le nouveau leader est bien '${secondLeader}'.`, 'pass');
                } else {
                    throw new Error(`Le nouveau leader √©lu ('${secondLeader}') n'est pas celui attendu ('${newExpectedLeader}').`);
                }

            } catch (error) {
                log(`Erreur critique durant le test: ${error.message}`, 'fail');
                testPassed = false;
            } finally {
                Object.values(workers).forEach(w => w.worker.terminate());
                mainBus.dispose();
                log('\n--- Test Termin√© ---', 'summary');
                if (testPassed) {
                    log('üéâ T√¢che "Heartbeat & D√©tection de Panne" valid√©e avec succ√®s !', 'pass');
                } else {
                    log('‚ùóÔ∏è Des probl√®mes ont √©t√© d√©tect√©s dans le cycle de r√©silience.', 'fail');
                }
            }
        });
    </script>
</body>
</html>

Conclusion de la T√¢che
Nous avons maintenant un syst√®me qui non seulement s'organise, mais qui peut aussi survivre √† la perte de son chef.

    Ce qui est fait :
        Le Leader envoie un "pouls" (heartbeat).
        Les Followers √©coutent ce pouls et d√©clenchent une nouvelle √©lection s'il s'arr√™te.
        L'√©tat du leader est g√©r√© de mani√®re centralis√©e dans le Guardian.
        Un test de bout en bout valide ce cycle complet de panne et de r√©cup√©ration.
