Ex√©cution : Sprint 1C - T√¢che des Jours 1-3 (Validation)
Objectif : Valider l'OfflineQueue avec un test d'int√©gration qui simule l'envoi d'un message √† un agent avant son d√©marrage.
Philosophie : Le test doit √™tre clair, d√©terministe et reproduire exactement le sc√©nario critique que l'on cherche √† r√©soudre.
Impl√©mentation du Test d'Int√©gration de l'OfflineQueue
1. Pr√©paration :
Nous allons cr√©er un nouveau fichier de test E2E d√©di√© √† cette fonctionnalit√©.
Bash

touch tests/browser/sprint1c-offline-queue-e2e.html

2. Mise √† Jour de l'Agent de Test :
Nous avons besoin d'un agent qui, une fois d√©marr√©, envoie un HEARTBEAT pour se signaler. Notre OrionGuardian le fait d√©j√†, donc notre PingAgent qui l'utilise est pr√™t.
3. Code Complet du Fichier de Test sprint1c-offline-queue-e2e.html :
Ce test va :

    Cr√©er un MessageBus pour l'agent "A".
    Envoyer une requ√™te de "A" vers "B", alors que "B" n'existe pas encore.
    Attendre un court instant.
    D√©marrer le worker de l'agent "B".
    V√©rifier que la requ√™te initiale de "A" se r√©sout correctement.

HTML

<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Kensho - Sprint 1C - Test E2E de l'OfflineQueue</title>
    <style>/* ... (m√™me style) ... */</style>
</head>
<body>
    <h1>Sprint 1C - Test E2E de l'OfflineQueue</h1>
    <p>Ce test valide que les messages envoy√©s √† un agent hors ligne sont mis en attente et d√©livr√©s lorsqu'il revient en ligne.</p>
    <button id="run-tests">Lancer le Test</button>
    <h2>R√©sultats :</h2>
    <pre id="results"></pre>

    <script type="module">
        const resultsEl = document.getElementById('results');
        const log = (message, status = 'info') => { /* ... (m√™me fonction log) ... */ };
        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
        const startWorker = (path) => { /* ... (m√™me fonction startWorker) ... */ };

        document.getElementById('run-tests').addEventListener('click', async () => {
            resultsEl.innerHTML = '';
            log('--- D√©marrage du test de l\'OfflineQueue ---', 'info');

            const { MessageBus } = await import('/src/core/communication/MessageBus.ts');
            let busA = null;
            let workerB = null;
            let testPassed = true;

            try {
                // --- √âtape 1: Envoyer un message dans le vide ---
                log('[√âtape 1] Cr√©ation de l\'AgentA et envoi d\'une requ√™te √† l\'AgentB (inexistant)...', 'info');
                busA = new MessageBus('AgentA');
                
                const requestPromise = busA.request('AgentB', { method: 'ping', args: ['hello offline'] });
                log('  Requ√™te envoy√©e. La promesse est maintenant en attente.', 'info');

                // --- √âtape 2: D√©marrer l'agent destinataire ---
                await sleep(500); // Attendre un peu pour s'assurer que la requ√™te est bien en attente
                log('\n[√âtape 2] D√©marrage de l\'AgentB...', 'info');
                
                workerB = await startWorker('/dist/test-agents/ping.agent.js');
                log('  AgentB a d√©marr√© et envoy√© son signal READY.', 'pass');
                
                // Le worker va s'annoncer via un broadcast. On doit donner le temps √† busA de le recevoir.
                log('  Attente de la d√©tection de l\'AgentB par l\'AgentA...', 'info');
                await sleep(500);

                // --- √âtape 3: V√©rifier la r√©solution de la promesse ---
                log('\n[√âtape 3] V√©rification de la r√©solution de la requ√™te initiale...', 'info');
                
                const response = await requestPromise;
                log(`  La promesse a √©t√© r√©solue avec la r√©ponse: "${response}"`, 'info');

                if (response === 'pong: hello offline') {
                    log('  La r√©ponse est correcte ! L\'OfflineQueue a fonctionn√©.', 'pass');
                } else {
                    throw new Error(`R√©ponse inattendue: ${response}`);
                }

                // --- Test de Timeout ---
                log('\n[Test de Timeout] V√©rification que la requ√™te √©choue si le worker ne revient jamais...', 'info');
                await expect(
                    busA.request('GhostAgent', { method: 'ping', args: [] }, 1000)
                ).rejects.toThrow("Le worker 'GhostAgent' n'est pas revenu en ligne dans le d√©lai de 1000ms.");
                log('  Le test de timeout a r√©ussi.', 'pass');


            } catch (error) {
                log(`Erreur critique durant le test: ${error.message}`, 'fail');
                testPassed = false;
            } finally {
                if (busA) busA.dispose();
                if (workerB) workerB.terminate();
                log('\n--- Test Termin√© ---', 'summary');
                if (testPassed) {
                    log('üéâ T√¢che "OfflineQueue" valid√©e avec succ√®s !', 'pass');
                } else {
                    log('‚ùóÔ∏è Des probl√®mes ont √©t√© d√©tect√©s dans la gestion de la file d\'attente hors ligne.', 'fail');
                }
            }
        });

        // Helper pour le test de timeout
        async function expect(promise) {
            return {
                async rejects(expectedError) {
                    try {
                        await promise;
                        throw new Error('La promesse aurait d√ª √™tre rejet√©e, mais elle a √©t√© r√©solue.');
                    } catch (error) {
                        if (error.message.includes(expectedError.message) || error.message.includes(expectedError)) {
                            // Test r√©ussi
                        } else {
                            throw new Error(`Erreur de promesse inattendue: "${error.message}" au lieu de "${expectedError.message}"`);
                        }
                    }
                }
            }
        }
    </script>
</body>
</html>

Conclusion de la T√¢che
Processus de Validation :

    Ex√©cuter npm run build:test-agents.
    Lancer le serveur de dev.
    Ouvrir tests/browser/sprint1c-offline-queue-e2e.html.
    Cliquer sur "Lancer le Test".
