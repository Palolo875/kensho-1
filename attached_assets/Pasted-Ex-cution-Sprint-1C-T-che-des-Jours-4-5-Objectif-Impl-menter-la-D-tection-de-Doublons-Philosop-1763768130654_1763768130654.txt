Ex√©cution : Sprint 1C - T√¢che des Jours 4-5
Objectif : Impl√©menter la D√©tection de Doublons
Philosophie : "Traiter une fois, et une seule." Pour garantir l'idempotence au niveau de la couche de transport, le MessageBus doit se souvenir des requ√™tes qu'il a r√©cemment trait√©es et retourner une r√©ponse mise en cache pour tout doublon, sans r√©-ex√©cuter la logique m√©tier.
Sous-√âtape 1 : Impl√©mentation de la Logique de D√©tection de Doublons
Nous allons modifier le MessageBus pour int√©grer ce m√©canisme de cache.
1. Mise √† Jour de MessageBus.ts :
TypeScript

// src/core/communication/MessageBus.ts
// ... (imports)

export class MessageBus {
    // ... (propri√©t√©s existantes)
    
    // NOUVEAU : Cache pour la d√©tection de doublons
    private recentlyProcessedRequests = new Map<string, { response: any, error?: SerializedError, timestamp: number }>();
    private cacheCleanupTimer: any;

    private static readonly CACHE_MAX_AGE_MS = 60000; // 60 secondes
    private static readonly CACHE_CLEANUP_INTERVAL_MS = 10000; // 10 secondes

    constructor(name: WorkerName, config: MessageBusConfig = {}) {
        // ... (constructeur existant)
        
        // D√©marrer le nettoyage p√©riodique du cache
        this.cacheCleanupTimer = setInterval(
            () => this.cleanupRequestCache(), 
            MessageBus.CACHE_CLEANUP_INTERVAL_MS
        );
    }

    private async processRequestMessage(message: KenshoMessage): Promise<void> {
        // NOUVEAU : V√©rifier le cache de d√©tection de doublons
        const cachedEntry = this.recentlyProcessedRequests.get(message.messageId);
        if (cachedEntry) {
            console.warn(`[MessageBus] Doublon de requ√™te d√©tect√© (${message.messageId}). Retour de la r√©ponse mise en cache.`);
            this.sendResponse(message, cachedEntry.response, cachedEntry.error);
            return;
        }

        if (!this.requestHandler) {
            const noHandlerError: SerializedError = { name: 'NoHandlerError', message: `No request handler registered for worker '${this.workerName}'` };
            this.recentlyProcessedRequests.set(message.messageId, { response: null, error: noHandlerError, timestamp: Date.now() });
            return this.sendResponse(message, null, noHandlerError);
        }
        
        try {
            const responsePayload = await this.requestHandler(message.payload);
            // Mettre en cache la r√©ponse en cas de succ√®s
            this.recentlyProcessedRequests.set(message.messageId, { response: responsePayload, timestamp: Date.now() });
            this.sendResponse(message, responsePayload);
        } catch (error) {
            const err = error instanceof Error ? error : new Error('Unknown error in request handler');
            const serializedError: SerializedError = {
                message: err.message,
                stack: err.stack,
                name: err.name,
            };
            // Mettre en cache la r√©ponse en cas d'erreur
            this.recentlyProcessedRequests.set(message.messageId, { response: null, error: serializedError, timestamp: Date.now() });
            this.sendResponse(message, null, serializedError);
        }
    }

    // NOUVEAU : Nettoyage p√©riodique du cache pour √©viter les fuites de m√©moire
    private cleanupRequestCache(): void {
        const now = Date.now();
        for (const [messageId, entry] of this.recentlyProcessedRequests.entries()) {
            if ((now - entry.timestamp) > MessageBus.CACHE_MAX_AGE_MS) {
                this.recentlyProcessedRequests.delete(messageId);
            }
        }
    }

    public dispose(): void {
        // ... (logique de dispose existante)
        clearInterval(this.cacheCleanupTimer);
    }

    // ... (le reste de la classe reste inchang√©)
}

    Commentaire : La logique est simple et efficace.
        √Ä la r√©ception d'une requ√™te, on v√©rifie si son messageId est dans le cache.
        Si oui, on renvoie la r√©ponse (ou l'erreur) mise en cache et on arr√™te le traitement.
        Si non, on traite la requ√™te normalement.
        Une fois le traitement termin√© (succ√®s ou erreur), on stocke le r√©sultat dans le cache avant de l'envoyer.
        Un setInterval nettoie p√©riodiquement les vieilles entr√©es du cache pour √©viter qu'il ne grossisse ind√©finiment.

Sous-√âtape 2 : Validation avec un Test d'Int√©gration
Objectif : Prouver que si le MessageBus re√ßoit deux fois la m√™me requ√™te, la logique m√©tier sous-jacente (requestHandler) n'est ex√©cut√©e qu'une seule fois.
1. Cr√©ation du Fichier de Test sprint1c-duplicate-detection-e2e.html :
Bash

touch tests/browser/sprint1c-duplicate-detection-e2e.html

2. Code Complet du Fichier de Test :
HTML

<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Kensho - Sprint 1C - Test E2E de D√©tection de Doublons</title>
    <style>/* ... (m√™me style) ... */</style>
</head>
<body>
    <h1>Sprint 1C - Test E2E de D√©tection de Doublons</h1>
    <p>Ce test valide que le MessageBus ignore les requ√™tes dupliqu√©es.</p>
    <button id="run-tests">Lancer le Test</button>
    <h2>R√©sultats :</h2>
    <pre id="results"></pre>

    <script type="module">
        const resultsEl = document.getElementById('results');
        const log = (message, status = 'info') => { /* ... */ };
        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        // Mock du BroadcastChannel pour contr√¥ler la livraison des messages
        const mockBusController = {
            listeners: [],
            postMessage(message) {
                // On ne livre pas imm√©diatement pour simuler un r√©seau
                setTimeout(() => this.listeners.forEach(l => l({ data: message })), 50);
            },
            addEventListener(handler) { this.listeners.push(handler); },
            clear() { this.listeners = []; }
        };
        window.BroadcastChannel = function() { return mockBusController; };


        document.getElementById('run-tests').addEventListener('click', async () => {
            resultsEl.innerHTML = '';
            log('--- D√©marrage du test de d√©tection de doublons ---', 'info');

            const { MessageBus } = await import('/src/core/communication/MessageBus.ts');
            let busA = null;
            let busB = null;
            let testPassed = true;

            try {
                // --- √âtape 1: Setup ---
                log('[√âtape 1] Cr√©ation de deux MessageBus (AgentA, AgentB)...', 'info');
                busA = new MessageBus('AgentA');
                busB = new MessageBus('AgentB');

                // Le handler de l'AgentB va incr√©menter un compteur pour tracer ses ex√©cutions
                let executionCount = 0;
                busB.setRequestHandler(async (payload) => {
                    executionCount++;
                    log(`  [AgentB] Handler ex√©cut√© (compteur: ${executionCount}).`, 'info');
                    await sleep(50); // Simuler un travail
                    return `Response for ${payload.data}`;
                });
                log('  Handler de l\'AgentB configur√© avec un compteur.', 'info');

                // --- √âtape 2: Envoyer une requ√™te dupliqu√©e ---
                log('\n[√âtape 2] Envoi de la m√™me requ√™te deux fois de suite...', 'info');
                
                // On doit construire le message manuellement pour avoir le m√™me messageId
                const traceId = `trace-${crypto.randomUUID()}`;
                const messageId = `msg-${crypto.randomUUID()}`;
                const payload = { data: 'test-duplicate' };

                const message = {
                    messageId, traceId, payload,
                    type: 'request',
                    sourceWorker: 'AgentA',
                    targetWorker: 'AgentB',
                };

                // On utilise une m√©thode interne pour envoyer un message d√©j√† construit
                // (On doit l'exposer pour le test)
                busA.resendMessage(message);
                busA.resendMessage(message);
                log('  Deux messages avec le m√™me ID ont √©t√© envoy√©s.', 'info');

                // Attendre que les r√©ponses reviennent (le timeout du bus est de 5s)
                await sleep(1000);

                // --- √âtape 3: V√©rification ---
                log('\n[√âtape 3] V√©rification du nombre d\'ex√©cutions...', 'info');
                if (executionCount === 1) {
                    log('Le handler n\'a √©t√© ex√©cut√© qu\'une seule fois.', 'pass');
                } else {
                    throw new Error(`Le handler a √©t√© ex√©cut√© ${executionCount} fois au lieu de 1.`);
                }

            } catch (error) {
                log(`Erreur critique durant le test: ${error.message}`, 'fail');
                testPassed = false;
            } finally {
                if (busA) busA.dispose();
                if (busB) busB.dispose();
                log('\n--- Test Termin√© ---', 'summary');
                if (testPassed) {
                    log('üéâ T√¢che "D√©tection de Doublons" valid√©e avec succ√®s !', 'pass');
                } else {
                    log('‚ùóÔ∏è Des probl√®mes ont √©t√© d√©tect√©s dans la gestion des doublons.', 'fail');
                }
            }
        });
    </script>
</body>
</html>

    Note : Pour ce test, nous avons besoin de rendre la m√©thode resendMessage (anciennement sendMessage) publique sur le MessageBus pour pouvoir envoyer manuellement un message avec un ID pr√©d√©fini.

Conclusion de la T√¢che
Processus de Validation :

    Lancer le serveur de dev.
    Ouvrir tests/browser/sprint1c-duplicate-detection-e2e.html.
    Cliquer sur "Lancer le Test".
