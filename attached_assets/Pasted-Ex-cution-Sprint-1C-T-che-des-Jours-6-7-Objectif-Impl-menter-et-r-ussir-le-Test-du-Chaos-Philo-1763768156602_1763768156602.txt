Ex√©cution : Sprint 1C - T√¢che des Jours 6-7
Objectif : Impl√©menter et r√©ussir le Test du Chaos
Philosophie : "Ce qui ne nous tue pas nous rend plus fort." Nous allons intentionnellement et de mani√®re r√©p√©t√©e "casser" notre syst√®me pour nous assurer qu'il est non seulement r√©silient (il survit), mais aussi anti-fragile (il revient toujours √† un √©tat de fonctionnement stable).
Impl√©mentation du Test du Chaos
1. Pr√©paration :
Nous allons cr√©er une page de test d√©di√©e qui va orchestrer un sc√©nario de chaos continu. Cette page sera notre "ar√®ne".
Bash

touch tests/browser/sprint1c-chaos-monkey-e2e.html

2. Code Complet du Fichier de Test sprint1c-chaos-monkey-e2e.html :
Ce test va :

    D√©marrer une constellation de plusieurs agents.
    Lancer un "Chaos Monkey" qui, √† intervalles al√©atoires, tue un agent au hasard.
    Pendant ce temps, un "Client" essaie continuellement de faire des requ√™tes √† des agents al√©atoires.
    Nous mesurerons le taux de succ√®s de ces requ√™tes. Un syst√®me robuste devrait maintenir un taux de succ√®s tr√®s √©lev√©, malgr√© le chaos.

HTML

<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Kensho - Sprint 1C - Test du Chaos</title>
    <style>
        /* ... (m√™me style) ... */
        #stats { display: flex; gap: 2em; margin-bottom: 1em; }
        .stat-card { background-color: #282c34; padding: 1em; border-radius: 8px; text-align: center; }
        .stat-card h3 { margin: 0 0 0.5em 0; color: #61afef; }
        .stat-card p { font-size: 1.5em; margin: 0; color: #d4d4d4; }
    </style>
</head>
<body>
    <h1>Sprint 1C - Test du Chaos (Chaos Monkey)</h1>
    <p>Ce test valide la robustesse de la constellation en tuant et red√©marrant des agents de mani√®re al√©atoire tout en effectuant des requ√™tes.</p>
    <button id="run-tests">Lancer le Chaos üêí</button>
    <div id="stats"></div>
    <h2>Journal des √âv√©nements :</h2>
    <pre id="results"></pre>

    <script type="module">
        const resultsEl = document.getElementById('results');
        const statsEl = document.getElementById('stats');
        const log = (message, status = 'info') => { /* ... */ };
        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
        
        // --- Configuration du Test ---
        const NUM_AGENTS = 5;
        const TEST_DURATION_MS = 30000; // 30 secondes de chaos
        const CHAOS_INTERVAL_MIN_MS = 2000;
        const CHAOS_INTERVAL_MAX_MS = 5000;
        const CLIENT_REQUEST_INTERVAL_MS = 200;

        let testRunning = false;

        document.getElementById('run-tests').addEventListener('click', async () => {
            if (testRunning) return;
            testRunning = true;
            resultsEl.innerHTML = '';
            statsEl.innerHTML = '';
            log('--- D√©marrage du Test du Chaos ---', 'info');

            const { MessageBus } = await import('/src/core/communication/MessageBus.ts');
            const mainBus = new MessageBus('MainThread');
            let workers = new Map();
            let stats = { requests: 0, successes: 0, failures: 0 };

            // --- Fonctions Helper ---
            async function startWorker(name) {
                const worker = new Worker('/dist/test-agents/ping.agent.js');
                // ... (logique de handshake READY, non montr√©e pour la clart√©)
                workers.set(name, worker);
                return worker;
            }

            function updateStats() {
                const successRate = stats.requests > 0 ? ((stats.successes / stats.requests) * 100).toFixed(2) : 'N/A';
                statsEl.innerHTML = `
                    <div class="stat-card"><h3>Requ√™tes Tent√©es</h3><p>${stats.requests}</p></div>
                    <div class="stat-card"><h3>Succ√®s</h3><p class="pass">${stats.successes}</p></div>
                    <div class="stat-card"><h3>√âchecs</h3><p class="fail">${stats.failures}</p></div>
                    <div class="stat-card"><h3>Taux de Succ√®s</h3><p>${successRate}%</p></div>
                `;
            }

            try {
                // --- √âtape 1: Initialisation de la Constellation ---
                log(`[INFO] D√©marrage de ${NUM_AGENTS} agents...`);
                for (let i = 0; i < NUM_AGENTS; i++) {
                    await startWorker(`Agent${i}`);
                }
                log('[PASS] Constellation initiale pr√™te.', 'pass');

                // --- √âtape 2: Lancement du Chaos Monkey et du Client ---
                const chaosMonkeyInterval = setInterval(() => {
                    if (workers.size === 0) return;
                    const workerNames = Array.from(workers.keys());
                    const victimName = workerNames[Math.floor(Math.random() * workerNames.length)];
                    const victimWorker = workers.get(victimName);
                    
                    log(`üêí Chaos Monkey tue ${victimName}...`, 'warn');
                    victimWorker.terminate();
                    workers.delete(victimName);

                    // Recr√©er le worker apr√®s un court d√©lai
                    setTimeout(() => {
                        log(`üîß R√©paration: red√©marrage de ${victimName}...`, 'info');
                        startWorker(victimName);
                    }, 1000);

                }, CHAOS_INTERVAL_MIN_MS + Math.random() * (CHAOS_INTERVAL_MAX_MS - CHAOS_INTERVAL_MIN_MS));

                const clientInterval = setInterval(async () => {
                    if (workers.size === 0) return;
                    const workerNames = Array.from(workers.keys());
                    const targetName = workerNames[Math.floor(Math.random() * workerNames.length)];
                    
                    stats.requests++;
                    try {
                        await mainBus.request(targetName, { method: 'ping', args: ['chaos'] }, 2000);
                        stats.successes++;
                    } catch (error) {
                        stats.failures++;
                        log(`Client a √©chou√© √† contacter ${targetName}: ${error.message}`, 'fail');
                    }
                    updateStats();
                }, CLIENT_REQUEST_INTERVAL_MS);

                // --- √âtape 3: Attendre la fin du test ---
                log(`[INFO] Le test s'ex√©cutera pendant ${TEST_DURATION_MS / 1000} secondes...`);
                await sleep(TEST_DURATION_MS);

                // --- √âtape 4: Nettoyage et Verdict ---
                clearInterval(chaosMonkeyInterval);
                clearInterval(clientInterval);
                workers.forEach(w => w.terminate());
                mainBus.dispose();

                log('\n--- Test du Chaos Termin√© ---', 'summary');
                const finalSuccessRate = (stats.successes / stats.requests) * 100;
                if (finalSuccessRate > 95) {
                    log(`üéâ Taux de succ√®s final: ${finalSuccessRate.toFixed(2)}%. Le syst√®me est robuste !`, 'pass');
                } else {
                    throw new Error(`Taux de succ√®s final trop bas: ${finalSuccessRate.toFixed(2)}%. Le syst√®me n'est pas assez robuste.`);
                }

            } catch (error) {
                log(`Erreur critique durant le test: ${error.message}`, 'fail');
            } finally {
                testRunning = false;
            }
        });
    </script>
</body>
</html>

Conclusion et Validation du Sprint 1
Processus de Validation Final :

    Ex√©cuter npm run build:test-agents.
    Lancer le serveur de dev.
    Ouvrir tests/browser/sprint1c-chaos-monkey-e2e.html.
    Cliquer sur "Lancer le Chaos üêí".
    Observer les statistiques et le journal pendant 30 secondes.

Crit√®re de Succ√®s :
√Ä la fin des 30 secondes, le Taux de Succ√®s affich√© doit √™tre sup√©rieur √† 95%.

    Pourquoi pas 100% ? Il est normal et attendu que quelques requ√™tes √©chouent. Une requ√™te peut √™tre envoy√©e √† un agent juste au moment o√π le Chaos Monkey le tue, et avant que la OfflineQueue n'ait le temps de prendre le relais. Un taux de succ√®s de >95% prouve que le syst√®me se r√©pare rapidement et que les pannes sont des √©v√©nements brefs et contenus.
