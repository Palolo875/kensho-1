Exécution : Sprint 5 - Tâche des Jours 7-9
Objectif : Intégrer l'IntentClassifier et le MemoryRetriever dans l'OIE
Philosophie : "Penser avant d'agir." Le cerveau de Kensho doit d'abord comprendre l'intention et se souvenir du passé avant de décider de la meilleure action à entreprendre.
Sous-Étape 1 : Implémentation du MemoryRetriever (Jour 7)
Ce composant est le cœur de la récupération de mémoire. Il implémente la logique de recherche large et de re-ranking que nous avons définie.
1. Création du Fichier MemoryRetriever.ts :
Bash

touch src/agents/graph/MemoryRetriever.ts

2. Code du MemoryRetriever.ts :
TypeScript

// src/agents/graph/MemoryRetriever.ts
import { AgentRuntime } from '../../core/agent-system/AgentRuntime';
import { HNSWManager } from './HNSWManager';
import { SQLiteManager } from './SQLiteManager';
import { IMemoryNode } from './types';

const RECALL_WIDTH = 20; // Récupérer 20 candidats
const FINAL_K = 3;       // Retourner les 3 meilleurs

export class MemoryRetriever {
    constructor(
        private runtime: AgentRuntime,
        private sqliteManager: SQLiteManager,
        private hnswManager: HNSWManager
    ) {}

    public async retrieve(query: string): Promise<IMemoryNode[]> {
        const startTime = performance.now();

        // Étape 1 : Obtenir l'embedding de la requête
        const queryEmbedding = await this.runtime.callAgent<number[]>(
            'EmbeddingAgent', 'embed', [{ text: query }]
        );

        // Étape 2 : Recherche vectorielle large (top-20)
        const candidates = await this.hnswManager.search(queryEmbedding, RECALL_WIDTH);
        if (candidates.length === 0) return [];

        // Étape 3 : Enrichissement avec les données de SQLite
        const db = await this.sqliteManager.getDb();
        const placeholders = candidates.map(() => '?').join(',');
        const enrichedCandidates = db.exec(`
            SELECT * FROM nodes WHERE id IN (${placeholders})
        `, candidates.map(c => c.id)).flatMap(res => res.values.map(row => {
            // Mapper la ligne SQL à l'interface IMemoryNode
            // ...
            return /* IMemoryNode */
        }));
        
        // Associer la distance de la recherche HNSW
        const candidateMap = new Map(enrichedCandidates.map(node => [node.id, node]));
        const candidatesWithDistance = candidates.map(c => ({
            node: candidateMap.get(c.id),
            distance: c.distance
        }));

        // Étape 4 : Re-ranking avec score composite
        const rankedCandidates = candidatesWithDistance
            .filter(c => c.node) // Filtrer les nœuds non trouvés
            .map(c => {
                const recencyScore = this.calculateRecencyScore(c.node.createdAt);
                const importanceScore = c.node.importance;
                // La similarité est l'inverse de la distance L2
                const similarityScore = 1 / (1 + c.distance);

                const compositeScore = 
                    (similarityScore * 0.6) + 
                    (recencyScore * 0.2) + 
                    (importanceScore * 0.2);
                
                return { node: c.node, score: compositeScore };
            });

        // Étape 5 : Retourner les top-k après re-ranking
        const finalMemories = rankedCandidates
            .sort((a, b) => b.score - a.score)
            .slice(0, FINAL_K)
            .map(r => r.node);

        this.runtime.log('info', `[MemoryRetriever] Récupération de ${finalMemories.length} souvenirs en ${performance.now() - startTime}ms.`);
        return finalMemories;
    }

    private calculateRecencyScore(createdAt: number): number {
        const ageInDays = (Date.now() - createdAt) / (1000 * 60 * 60 * 24);
        return Math.exp(-ageInDays / 30); // Décroissance exponentielle avec une demi-vie de 30 jours
    }
}

    Commentaire : Cette classe implémente notre stratégie de rappel intelligente. Elle ne se contente pas de la similarité brute, mais pondère les résultats avec la fraîcheur et l'importance, garantissant que les souvenirs les plus pertinents remontent.

Sous-Étape 2 : Intégration dans l'OIE (Jours 8-9)
Maintenant, nous modifions le CognitiveProcessor de l'OIE pour utiliser ces nouveaux services.
1. Mise à Jour du CognitiveProcessor.ts :
TypeScript

// src/core/oie/CognitiveProcessor.ts
import { AgentRuntime } from '../agent-system/AgentRuntime';
import { Intent, IntentClassifierAgent } from '../../agents/intent-classifier'; // Importer les types
import { MemoryRetriever } from '../../agents/graph/MemoryRetriever';
// ...

export class CognitiveProcessor {
    private runtime: AgentRuntime;
    private memoryRetriever: MemoryRetriever; // Le retriever est maintenant une dépendance

    constructor(task: Task, runtime: AgentRuntime) {
        this.runtime = runtime;
        // Initialiser le retriever avec les dépendances nécessaires
        this.memoryRetriever = new MemoryRetriever(runtime, /* sqliteManager */, /* hnswManager */);
        // ...
    }

    public async run(): Promise<void> {
        // --- ÉTAPE 1: CLASSIFICATION DE L'INTENTION ---
        const intent = await this.runtime.callAgent<Intent>(
            'IntentClassifierAgent', 'classify', [{ text: this.task.query }]
        );

        // --- ÉTAPE 2: ACTION BASÉE SUR L'INTENTION ---
        switch (intent.type) {
            case 'MEMORIZE':
                await this.handleMemorize(intent);
                return; // Termine le cycle
            case 'FORGET':
                await this.handleForget(intent);
                return; // Termine le cycle
            case 'CHAT':
            default:
                // Continue vers la planification normale
                break;
        }

        // --- ÉTAPE 3: RAPPEL CONTEXTUEL ---
        const relevantMemories = await this.memoryRetriever.retrieve(this.task.query);
        this.task.context.memories = relevantMemories; // Ajoute les souvenirs au contexte

        // --- ÉTAPE 4: PLANIFICATION ET EXÉCUTION (comme dans le Sprint 3) ---
        const plan = await this.llmPlanner.generatePlan(this.task);
        const finalResult = await this.taskExecutor.execute(plan, this.task.context);

        this.runtime.send(this.task.source, {
            type: 'task-stream-end',
            payload: { finalResult }
        });
    }

    private async handleMemorize(intent: { content: string }): Promise<void> {
        await this.runtime.callAgent('GraphWorker', 'addNode', [{
            content: intent.content,
            type: 'user.stated',
            // ... autres métadonnées
        }]);
        this.runtime.send(this.task.source, {
            type: 'task-stream-end',
            payload: { finalResult: "C'est noté. Je m'en souviendrai." }
        });
    }

    private async handleForget(intent: { content: string, scope: 'ALL' | 'NODE' }): Promise<void> {
        // Logique pour appeler GraphWorker.deleteNode ou deleteNodesByTopic
        // ...
        this.runtime.send(this.task.source, {
            type: 'task-stream-end',
            payload: { finalResult: "D'accord, j'ai oublié cette information." }
        });
    }
}

    Commentaire : Le CognitiveProcessor est maintenant beaucoup plus intelligent.
        Il comprend les intentions de l'utilisateur avant de faire quoi que ce soit.
        Il gère directement les commandes de mémoire (MEMORIZE, FORGET), ce qui est très efficace.
        Pour les questions normales (CHAT), il enrichit le contexte avec des souvenirs pertinents avant de passer la main au planificateur.

Conclusion de la Tâche
La tâche des Jours 7-9 est terminée. Le cerveau de Kensho a maintenant un "hippocampe" fonctionnel.

    Ce qui est fait :
        Un MemoryRetriever intelligent qui trouve les souvenirs les plus pertinents.
        Un CognitiveProcessor mis à jour qui intègre un cycle complet : Intention -> Rappel -> Planification -> Action.
