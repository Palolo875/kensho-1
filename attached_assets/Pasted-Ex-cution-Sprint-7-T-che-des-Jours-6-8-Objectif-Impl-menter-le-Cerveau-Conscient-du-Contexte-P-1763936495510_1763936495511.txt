Exécution : Sprint 7 - Tâche des Jours 6-8
Objectif : Implémenter le Cerveau Conscient du Contexte
Philosophie : "Donner un but à l'IA." Chaque action de Kensho doit être contextualisée par le projet en cours et viser à faire avancer l'utilisateur vers son objectif.
Sous-Étape 1 : Implémentation du ProjectContextBuilder (Jour 6)
C'est le composant qui empêchera la saturation du prompt. Il sélectionne intelligemment les informations les plus pertinentes à remonter à l'IA.
1. Création du Fichier ProjectContextBuilder.ts :
Bash

touch src/core/oie/ProjectContextBuilder.ts

2. Code du ProjectContextBuilder.ts :
TypeScript

// src/core/oie/ProjectContextBuilder.ts
import { Project, ProjectTask } from '../../agents/graph/types';

const MAX_TASKS_IN_CONTEXT = 5;

export class ProjectContextBuilder {
    public build(project: Project, tasks: ProjectTask[]): string {
        const incompleteTasks = tasks.filter(t => !t.completed);
        
        // Pour ce sprint, la stratégie de sélection est simple : les plus récentes.
        const relevantTasks = incompleteTasks
            .sort((a, b) => b.createdAt - a.createdAt)
            .slice(0, MAX_TASKS_IN_CONTEXT);

        const completedCount = tasks.length - incompleteTasks.length;

        return `
**CONTEXTE DU PROJET ACTIF :**
- Nom : ${project.name}
- Objectif Principal : ${project.goal}
- Progression : ${completedCount}/${tasks.length} tâches complétées.
- Tâches prioritaires restantes :
${relevantTasks.map(t => `  - [ ] ${t.text}`).join('\n')}
${incompleteTasks.length > MAX_TASKS_IN_CONTEXT ? `... et ${incompleteTasks.length - MAX_TASKS_IN_CONTEXT} autres tâches.` : ''}
        `.trim();
    }
}

    Commentaire : Simple, efficace, et respecte notre contrainte de ne pas saturer le prompt. La stratégie de sélection pourra être améliorée plus tard avec de la pertinence sémantique.

Sous-Étape 2 : Mise à Jour du Prompt Système et du TaskCompletionDetector (Jour 7)
Nous enseignons au MainLLMAgent comment utiliser ce nouveau contexte et comment signaler la complétion des tâches.
1. Mise à Jour du Prompt Système du MainLLMAgent :
TypeScript

// src/agents/main-llm/system-prompt.ts

export const MAIN_SYSTEM_PROMPT = `
Tu es Kensho, un partenaire de projet personnel et intelligent.

{{project_context}} // Ce bloc sera remplacé par le contexte du projet

**TA MISSION :**
Ta mission principale est d'aider l'utilisateur à accomplir l'objectif du projet. Chaque réponse doit, si possible, faire avancer une des tâches.

**RÈGLE CRITIQUE : Marquage des Tâches**
Quand tu estimes qu'une tâche est terminée grâce à ta réponse, tu DOIS inclure EXACTEMENT cette ligne (en PLUS de ta réponse naturelle) :
[TASK_COMPLETED: "texte exact de la tâche"]

Si tu n'es PAS SÛR qu'une tâche est terminée, NE METS PAS la balise.
`.trim();

2. Implémentation du TaskCompletionDetector.ts :
C'est le composant qui valide la complétion de tâche de manière robuste, en utilisant la similarité d'embedding.
TypeScript

// src/core/oie/TaskCompletionDetector.ts
import { AgentRuntime } from '../agent-system/AgentRuntime';
import { ProjectTask } from '../../agents/graph/types';

const SIMILARITY_THRESHOLD = 0.92;

export class TaskCompletionDetector {
    constructor(private runtime: AgentRuntime) {}

    public async detect(llmResponse: string, projectTasks: ProjectTask[]): Promise<ProjectTask | null> {
        const explicitMatch = llmResponse.match(/\[TASK_COMPLETED: "(.+?)"\]/);
        if (!explicitMatch) {
            return null;
        }

        const mentionedTaskText = explicitMatch[1];
        const incompleteTasks = projectTasks.filter(t => !t.completed);

        if (incompleteTasks.length === 0) return null;

        // Obtenir les embeddings en parallèle
        const [mentionedEmbedding, taskEmbeddings] = await Promise.all([
            this.runtime.callAgent<number[]>('EmbeddingAgent', 'embed', [{ text: mentionedTaskText }]),
            this.runtime.callAgent<number[][]>('EmbeddingAgent', 'embedBatch', [{ texts: incompleteTasks.map(t => t.text) }])
        ]);

        // Calculer la similarité et trouver la meilleure correspondance
        let bestMatch: ProjectTask | null = null;
        let bestSimilarity = -1;

        for (let i = 0; i < incompleteTasks.length; i++) {
            const similarity = this.cosineSimilarity(mentionedEmbedding, taskEmbeddings[i]);
            if (similarity > bestSimilarity) {
                bestSimilarity = similarity;
                bestMatch = incompleteTasks[i];
            }
        }

        if (bestMatch && bestSimilarity > SIMILARITY_THRESHOLD) {
            this.runtime.log('info', `[TaskCompletionDetector] Tâche complétée détectée avec une similarité de ${bestSimilarity.toFixed(2)}.`);
            return bestMatch;
        }

        this.runtime.log('warn', `[TaskCompletionDetector] Balise détectée mais similarité trop faible (${bestSimilarity.toFixed(2)}).`);
        return null;
    }

    private cosineSimilarity(vecA: number[], vecB: number[]): number {
        // ... (implémentation de la similarité cosinus)
        return /* ... */;
    }
}

    Commentaire : Cette implémentation est blindée. Elle ne fait pas confiance au texte exact, mais valide l'intention sémantique, ce qui la rend résistante aux petites variations de formulation du LLM.

Sous-Étape 3 : Intégration dans le CognitiveProcessor (Jour 8)
Nous assemblons toutes les pièces dans le cerveau de Kensho.
1. Mise à Jour du CognitiveProcessor.ts :
TypeScript

// src/core/oie/CognitiveProcessor.ts
// ... (imports)
import { ProjectContextBuilder } from './ProjectContextBuilder';
import { TaskCompletionDetector } from './TaskCompletionDetector';

export class CognitiveProcessor {
    private contextBuilder = new ProjectContextBuilder();
    private taskDetector: TaskCompletionDetector;

    constructor(task: Task, runtime: AgentRuntime) {
        // ...
        this.taskDetector = new TaskCompletionDetector(runtime);
    }

    public async run(): Promise<void> {
        // ... (logique de classification d'intention)

        // --- NOUVEAU : Récupération et Injection du Contexte Projet ---
        const project = await this.runtime.callAgent('GraphWorker', 'getProject', [{ id: this.task.context.projectId }]);
        const tasks = await this.runtime.callAgent('GraphWorker', 'getProjectTasks', [{ projectId: this.task.context.projectId }]);
        
        if (project && tasks) {
            const projectContext = this.contextBuilder.build(project, tasks);
            this.task.context.projectContext = projectContext; // Pour le prompt
        }

        // ... (logique de rappel de mémoire du Sprint 5)

        // --- Exécution du plan ---
        const finalResult = await this.taskExecutor.execute(plan, this.task.context);

        // --- NOUVEAU : Détection de la Complétion de Tâche ---
        if (project && tasks) {
            const completedTask = await this.taskDetector.detect(finalResult, tasks);
            if (completedTask) {
                await this.runtime.callAgent('GraphWorker', 'toggleTask', [{ taskId: completedTask.id, completed: true }]);
            }
        }

        // Nettoyer la balise de la réponse finale avant de l'envoyer à l'UI
        const cleanResult = finalResult.replace(/\[TASK_COMPLETED: "(.+?)"\]/g, '').trim();

        this.runtime.send(this.task.source, {
            type: 'task-stream-end',
            payload: { finalResult: cleanResult }
        });
    }
}

    Commentaire : Le flux est complet. Le processeur récupère le contexte du projet, l'injecte, exécute le plan, puis analyse la réponse pour détecter les tâches complétées avant de renvoyer un résultat propre à l'utilisateur.

Conclusion de la Tâche
La tâche des Jours 6-8 est terminée. Le cerveau de Kensho est maintenant pleinement "conscient" des projets.

    Ce qui est fait :
        Un ProjectContextBuilder qui protège le prompt de la saturation.
        Un TaskCompletionDetector robuste qui utilise la sémantique pour valider les actions de l'IA.
        Un CognitiveProcessor qui orchestre ce nouveau flux de conscience de projet.
