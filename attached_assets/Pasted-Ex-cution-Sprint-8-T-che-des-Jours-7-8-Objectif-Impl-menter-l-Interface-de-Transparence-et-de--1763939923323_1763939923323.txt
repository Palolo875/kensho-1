Ex√©cution : Sprint 8 - T√¢che des Jours 7-8
Objectif : Impl√©menter l'Interface de Transparence et de Feedback Actif
Philosophie : "La confiance na√Æt de la transparence. L'am√©lioration na√Æt du feedback." Nous allons donner √† l'utilisateur une vue claire sur le raisonnement de l'IA et un moyen simple de dire si ce raisonnement a √©t√© utile.
Sous-√âtape 3.1 : Mise √† Jour du CognitiveProcessor pour le Journaling
Le processeur doit maintenant construire et retourner un JournalCognitif d√©taill√©.
Fichier : src/core/oie/CognitiveProcessor.ts (extrait)
TypeScript

// ... (dans la m√©thode run)

// Apr√®s l'ex√©cution du plan par le TaskExecutor
const { finalResponse, journal } = await this.taskExecutor.execute(plan, context);

// Enrichir le journal avec des informations finales
journal.setFinalResponse(finalResponse);
journal.end();

// Envoyer la r√©ponse finale et le journal √† l'UI
this.runtime.sendToUI('final-response', {
    queryId: this.task.id,
    content: finalResponse,
    journal: journal.serialize() // S√©rialiser le journal pour le transport
});

    Commentaire : Le CognitiveProcessor ne retourne plus une simple cha√Æne de caract√®res, mais un objet contenant la r√©ponse et le journal s√©rialis√©.

Sous-√âtape 3.2 : Mise √† Jour de l'UI (JournalCognitif.tsx et ChatMessage.tsx)
Nous allons cr√©er les composants React pour afficher ces nouvelles informations.
Fichier : src/ui/components/JournalCognitif.tsx
TypeScript

// src/ui/components/JournalCognitif.tsx
import React from 'react';
import { SerializedJournal } from '../../core/oie/JournalCognitif';

interface JournalProps {
  journal: SerializedJournal;
}

// Un composant pour afficher une seule √©tape du journal
const JournalStep: React.FC<{ step: any }> = ({ step }) => (
    <div className="journal-step">
        <h4>{step.title} ({step.duration.toFixed(0)}ms)</h4>
        <pre>{step.content}</pre>
        {step.meta && <small>Meta: {JSON.stringify(step.meta)}</small>}
    </div>
);

export const JournalCognitif: React.FC<JournalProps> = ({ journal }) => {
    if (!journal || journal.type !== 'debate') return null;

    return (
        <div className="journal-container">
            <h3>Processus de R√©flexion ({journal.totalDuration.toFixed(0)}ms)</h3>
            {journal.steps.map((step, index) => (
                <JournalStep key={index} step={step} />
            ))}
        </div>
    );
};

Fichier : src/ui/components/ChatMessage.tsx (extrait)
TypeScript

// ...

const ChatMessage: React.FC<{ message: Message }> = ({ message }) => {
    const [showJournal, setShowJournal] = useState(false);

    // ...

    return (
        <div className={`message ${message.role}`}>
            {/* ... (contenu du message) */}

            {message.journal && message.journal.type === 'debate' && (
                <div className="message-actions">
                    <button onClick={() => setShowJournal(!showJournal)}>
                        üß† {showJournal ? 'Masquer' : 'Voir'} la r√©flexion
                    </button>
                    
                    {/* NOUVEAU : Boutons de satisfaction */}
                    <div className="satisfaction-buttons">
                        <button title="Utile" onClick={() => logSatisfaction(message.id, 5)}>üéØ</button>
                        <button title="Moyen" onClick={() => logSatisfaction(message.id, 3)}>ü§∑</button>
                        <button title="Inutile" onClick={() => logSatisfaction(message.id, 1)}>üí©</button>
                    </div>
                </div>
            )}

            {showJournal && message.journal && <JournalCognitif journal={message.journal} />}
        </div>
    );
};

    Commentaire : Le ChatMessage affiche maintenant conditionnellement le bouton "Voir la r√©flexion" et les nouveaux boutons de satisfaction si un journal de d√©bat est pr√©sent. Le JournalCognitif it√®re sur les √©tapes enregistr√©es pour les afficher.

Sous-√âtape 3.3 : Impl√©mentation du Stockage du Feedback
Nous devons cr√©er la logique pour enregistrer le feedback de l'utilisateur.
Fichier : src/lib/db.ts (extrait de SQLiteManager)
TypeScript

// ... (dans la m√©thode initializeSchema)

// NOUVELLE TABLE
db.run(`
    CREATE TABLE IF NOT EXISTS debate_feedback (
        id TEXT PRIMARY KEY,
        trace_id TEXT NOT NULL,
        query_id TEXT NOT NULL,
        satisfaction_score INTEGER NOT NULL,
        timestamp INTEGER NOT NULL
    )
`);

Fichier : src/ui/hooks/useChat.ts (extrait)
TypeScript

// ...

const useChat = () => {
    // ...

    const logSatisfaction = (queryId: string, score: number) => {
        console.log(`Satisfaction pour ${queryId}: ${score}/5`);
        // Envoyer un message au GraphWorker pour enregistrer le feedback
        // Note : On pourrait cr√©er un 'FeedbackAgent' d√©di√© plus tard.
        runtime.callAgent('GraphWorker', 'logDebateFeedback', [{
            queryId,
            score
        }]);
    };

    return { messages, sendMessage, logSatisfaction };
};

Fichier : src/agents/GraphWorker/index.ts (extrait)
TypeScript

// ... (dans defineAgent)

public: {
    // ... (m√©thodes existantes)

    async logDebateFeedback(args: { queryId: string, score: number }): Promise<void> {
        const message = this.sqliteManager.db.exec(
            "SELECT trace_id FROM messages WHERE id = ?", 
            [args.queryId]
        )[0]?.values[0]?.[0];

        if (!message) {
            console.error(`[GraphWorker] Impossible de trouver le trace_id pour le message ${args.queryId}`);
            return;
        }

        this.sqliteManager.db.run(
            "INSERT INTO debate_feedback (id, trace_id, query_id, satisfaction_score, timestamp) VALUES (?, ?, ?, ?, ?)",
            [crypto.randomUUID(), message.trace_id, args.queryId, args.score, Date.now()]
        );
        this.sqliteManager.setDirty(); // Marquer la DB pour sauvegarde
    }
}

    Commentaire : Nous avons ajout√© une nouvelle table pour le feedback. L'UI appelle une nouvelle m√©thode de l'agent GraphWorker qui enregistre le score de satisfaction, en le liant au traceId de la conversation pour une analyse future par le DebateOptimizer.

Conclusion de la T√¢che

    Statut : ‚úÖ Termin√©.
    Livrables :
        Un composant JournalCognitif qui affiche les √©tapes d'un d√©bat.
        Des boutons de satisfaction sur les messages issus d'un d√©bat.
        La logique backend pour stocker ce feedback de mani√®re persistante.

L'utilisateur ne voit plus une bo√Æte noire qui "r√©fl√©chit", mais un partenaire dont il peut suivre le raisonnement et √©valuer la performance. C'est une √©tape fondamentale pour la confiance et l'am√©lioration continue.