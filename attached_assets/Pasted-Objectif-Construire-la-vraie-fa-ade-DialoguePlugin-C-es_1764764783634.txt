Objectif : Construire la vraie fa√ßade DialoguePlugin. C'est le chef d'orchestre final, le point d'entr√©e unique pour l'UI. Il doit utiliser tous les services que nous avons construits : ResponseCache, Router, TaskExecutor, Fusioner, et communiquer son √©tat via le SSEStreamer.
Philosophie "Usine Vide" : C'est la t√¢che d'int√©gration la plus importante. Elle connecte tous nos composants (qui utilisent des mocks de bas niveau) en un flux de travail coh√©rent et complet.
Impl√©mentation du DialoguePlugin de Production
TypeScript

// src/core/plugins/DialoguePlugin.ts (VRAIE Impl√©mentation)

import { router } from '../kernel/Router';
import { taskExecutor } from '../kernel/TaskExecutor';
import { fusioner, TaskResult } from '../kernel/Fusioner';
import { responseCache } from '../kernel/ResponseCache';
import { sseStreamer } from '../kernel/streaming/SSEStreamer';
import { inputFilter } from '../kernel/guardrails/InputFilter';
import { outputGuard } from '../kernel/guardrails/OutputGuard';

console.log("üîå DialoguePlugin (Production) initialis√©.");

class DialoguePlugin {
  /**
   * Traite une requ√™te utilisateur de bout en bout.
   * C'est la m√©thode principale appel√©e par l'UI.
   */
  public async process(prompt: string): Promise<void> {
    try {
      // 0. Valider l'entr√©e
      const validation = inputFilter.validate(prompt);
      if (!validation.safe) {
        throw new Error(validation.reason || "Prompt invalide.");
      }

      // 1. D√©marrer le monitoring
      // Le planId sera g√©n√©r√© par le router, on le passe au monitoring
      // Pour l'instant, on signale juste le d√©but.
      sseStreamer.streamStatus("D√©but de l'ex√©cution...");

      // 2. V√©rifier le cache
      // Pour la simulation, on suppose un mod√®le de dialogue par d√©faut
      const defaultDialogueModel = "dialogue-gemma-mock";
      const cachedResponse = responseCache.get(prompt, defaultDialogueModel);
      if (cachedResponse) {
        sseStreamer.streamStatus("R√©ponse trouv√©e dans le cache.");
        sseStreamer.streamComplete(cachedResponse);
        return;
      }

      // 3. Cr√©er un plan d'ex√©cution
      sseStreamer.streamStatus("Planification en cours...");
      const plan = await router.createPlan(prompt);
      
      // On peut maintenant d√©marrer le monitoring avec l'ID du plan
      sseStreamer.emit('START_EXECUTION', { planId: plan.id });

      // 4. Ex√©cuter le plan
      sseStreamer.streamStatus(`Ex√©cution du plan (${plan.strategy})...`);
      const results: TaskResult[] = await taskExecutor.executePlan(plan);

      // 5. Fusionner les r√©sultats
      sseStreamer.streamStatus("Fusion des r√©sultats...");
      // On suppose que la premi√®re t√¢che est la primaire
      const primaryResult = results[0];
      const expertResults = results.slice(1);
      const fusedResponse = fusioner.fuse(primaryResult, expertResults);

      // 6. Valider la sortie
      const sanitizedResponse = outputGuard.sanitize(fusedResponse);

      // 7. Envoyer la r√©ponse finale
      sseStreamer.streamStatus("Ex√©cution termin√©e.");
      sseStreamer.streamComplete(sanitizedResponse);

      // 8. Mettre en cache la r√©ponse finale
      responseCache.set(prompt, defaultDialogueModel, sanitizedResponse);

    } catch (error) {
      const err = error as Error;
      console.error("[DialoguePlugin] Erreur dans le pipeline:", err);
      sseStreamer.streamError(err);
    }
  }
}

export const dialoguePlugin = new DialoguePlugin();

Statut : T√¢che #13 du Manifeste - TERMIN√âE.
Le DialoguePlugin est assembl√©. C'est la pi√®ce ma√Ætresse qui connecte tout.
Regardez la beaut√© de cette architecture :

    Le DialoguePlugin est simple. Il ne contient aucune logique m√©tier complexe.
    Il agit comme un chef d'orchestre, appelant chaque service sp√©cialis√© dans le bon ordre.
    Chaque √©tape est observable via le SSEStreamer.
