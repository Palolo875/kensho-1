Objectif : Construire le vrai MemoryManager. Il doit √™tre capable de suivre les mod√®les (factices) charg√©s en m√©moire, calculer leur "poids" virtuel, et fournir des informations au Router pour qu'il puisse prendre des d√©cisions √©clair√©es.
Philosophie "Usine Vide" : Le MemoryManager ne d√©chargera aucun vrai mod√®le. Il manipulera une liste interne de loadedModels et simulera les calculs de VRAM bas√©s sur un catalogue de mocks.
√âtape 1 : Mise √† jour du ModelCatalog avec des poids virtuels
TypeScript

// src/core/kernel/ModelCatalog.ts (Mise √† jour)

export const MOCK_MODEL_CATALOG = {
  "dialogue-gemma-mock": { specialty: 'DIALOGUE', virtual_vram_gb: 0.5 },
  "code-qwen-mock": { specialty: 'CODE', virtual_vram_gb: 1.8 },
  "math-bitnet-mock": { specialty: 'MATH', virtual_vram_gb: 1.2 },
  // ... etc.
};

export type MockModelKey = keyof typeof MOCK_MODEL_CATALOG;

√âtape 2 : Impl√©mentation du MemoryManager de Production
TypeScript

// src/core/kernel/MemoryManager.ts (VRAIE Impl√©mentation)

import { MOCK_MODEL_CATALOG, MockModelKey } from './ModelCatalog';

console.log("üß† MemoryManager (Production) initialis√©.");

type LoadedModelInfo = {
  key: MockModelKey;
  vram: number;
  loadedAt: number;
};

class MemoryManager {
  private loadedModels: Map<MockModelKey, LoadedModelInfo> = new Map();
  private readonly TOTAL_VIRTUAL_VRAM_GB = 8; // Simule une machine avec 8GB de VRAM

  /**
   * Enregistre un mod√®le comme √©tant "charg√©" en m√©moire.
   */
  public registerLoaded(modelKey: MockModelKey): void {
    if (this.loadedModels.has(modelKey)) {
      console.log(`[MemoryManager] ${modelKey} est d√©j√† charg√©.`);
      return;
    }
    const modelInfo = MOCK_MODEL_CATALOG[modelKey];
    if (!modelInfo) {
      console.error(`[MemoryManager] Tentative de charger un mod√®le inconnu: ${modelKey}`);
      return;
    }
    this.loadedModels.set(modelKey, {
      key: modelKey,
      vram: modelInfo.virtual_vram_gb,
      loadedAt: Date.now(),
    });
    console.log(`[MemoryManager] ‚úÖ Mod√®le "${modelKey}" charg√© (VRAM virtuelle: ${modelInfo.virtual_vram_gb}GB).`);
    this.logStats();
  }

  /**
   * Enregistre un mod√®le comme √©tant "d√©charg√©".
   */
  public registerUnloaded(modelKey: MockModelKey): void {
    if (this.loadedModels.delete(modelKey)) {
      console.log(`[MemoryManager] ‚õî Mod√®le "${modelKey}" d√©charg√©.`);
      this.logStats();
    }
  }

  /**
   * V√©rifie s'il y a assez de VRAM virtuelle pour charger un nouveau mod√®le.
   */
  public canLoadModel(modelKey: MockModelKey): boolean {
    const modelInfo = MOCK_MODEL_CATALOG[modelKey];
    if (!modelInfo) return false;

    const requiredVRAM = modelInfo.virtual_vram_gb;
    const usedVRAM = this.getUsedVRAM();
    const availableVRAM = this.TOTAL_VIRTUAL_VRAM_GB - usedVRAM;

    return requiredVRAM <= availableVRAM;
  }

  private getUsedVRAM(): number {
    return Array.from(this.loadedModels.values()).reduce((sum, model) => sum + model.vram, 0);
  }

  public logStats(): void {
    const usedVRAM = this.getUsedVRAM();
    const percentage = ((usedVRAM / this.TOTAL_VIRTUAL_VRAM_GB) * 100).toFixed(1);
    console.log(`[MemoryManager] Stats: ${this.loadedModels.size} mod√®les charg√©s, ${usedVRAM.toFixed(2)}/${this.TOTAL_VIRTUAL_VRAM_GB}GB VRAM utilis√©e (${percentage}%).`);
  }
}

export const memoryManager = new MemoryManager();

Statut : T√¢che #5 du Manifeste - TERMIN√âE.
Le MemoryManager est construit. Il est pr√™t √† √™tre utilis√© par le Router pour prendre des d√©cisions bas√©es sur une simulation r√©aliste de la consommation m√©moire, et par le TaskExecutor pour enregistrer les mod√®les qu'il "charge" ou "d√©charge".