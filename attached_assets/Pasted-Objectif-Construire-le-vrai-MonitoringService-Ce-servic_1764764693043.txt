Objectif : Construire le vrai MonitoringService. Ce service s'abonnera √† notre SSEStreamer pour √©couter les √©v√©nements cl√©s et calculera des m√©triques de performance en temps r√©el.
Philosophie "Usine Vide" : Le service est celui de production. Il calculera des m√©triques r√©elles (temps √©coul√©, etc.) bas√©es sur les √©v√©nements de notre flux simul√©. Pour l'instant, il affichera ses r√©sultats dans la console. Plus tard, ces donn√©es pourront alimenter un v√©ritable dashboard dans l'UI.
Impl√©mentation du MonitoringService de Production
TypeScript

// src/core/kernel/monitoring/MonitoringService.ts (VRAIE Impl√©mentation)

import { sseStreamer, StreamEvent } from '../streaming/SSEStreamer';

console.log("üìä MonitoringService (Production) initialis√©.");

class MonitoringService {
  private startTime: number = 0;
  private firstTokenTime: number | null = null;
  private tokenCount: number = 0;
  private currentPlanId: string | null = null;

  constructor() {
    this.listenToEvents();
  }

  /**
   * S'abonne aux √©v√©nements du SSEStreamer pour collecter des m√©triques.
   */
  private listenToEvents(): void {
    // √âcoute un √©v√©nement 'START_EXECUTION' qui sera √©mis par le DialoguePlugin
    sseStreamer.on('START_EXECUTION', (event: StreamEvent) => {
      this.reset(event.payload.planId);
      console.log(`[Monitor] üìà Nouvelle ex√©cution d√©marr√©e: ${this.currentPlanId}`);
    });

    sseStreamer.on('TOKEN', (event: StreamEvent) => {
      if (this.startTime === 0) return; // Ne fait rien si l'ex√©cution n'a pas d√©marr√©

      if (this.firstTokenTime === null) {
        this.firstTokenTime = Date.now();
        const ttft = this.firstTokenTime - this.startTime;
        console.log(`[Monitor] ‚ö° Time To First Token (TTFT): ${ttft}ms`);
      }
      this.tokenCount++;
    });

    sseStreamer.on('COMPLETE', (event: StreamEvent) => {
      if (this.startTime === 0) return;

      const totalTime = Date.now() - this.startTime;
      const tokensPerSec = this.tokenCount > 0 ? (this.tokenCount / totalTime * 1000) : 0;

      const finalMetrics = {
        planId: this.currentPlanId,
        ttft: this.firstTokenTime ? this.firstTokenTime - this.startTime : totalTime,
        totalTime,
        tokenCount: this.tokenCount,
        tokensPerSecond: parseFloat(tokensPerSec.toFixed(2)),
      };

      console.log('[Monitor] üìä M√©triques Finales:', finalMetrics);
      
      // √âmet un √©v√©nement de m√©triques pour que d'autres services (ou l'UI) puissent l'utiliser
      sseStreamer.emit('METRICS', finalMetrics);
      
      this.reset(); // R√©initialise pour la prochaine ex√©cution
    });

    sseStreamer.on('ERROR', (event: StreamEvent) => {
      console.error('[Monitor] üìâ Erreur d√©tect√©e pendant l\'ex√©cution.', event.payload);
      this.reset();
    });
  }

  /**
   * R√©initialise les compteurs pour une nouvelle ex√©cution.
   */
  private reset(planId: string | null = null): void {
    this.startTime = planId ? Date.now() : 0;
    this.firstTokenTime = null;
    this.tokenCount = 0;
    this.currentPlanId = planId;
  }
}

// Initialise le service pour qu'il commence √† √©couter imm√©diatement.
export const monitoringService = new MonitoringService();

Statut : T√¢che #12 du Manifeste - TERMIN√âE.
Le MonitoringService est en place et √† l'√©coute. Il est comme une √©quipe d'analystes qui regarde les √©crans de contr√¥le de l'usine 24h/24.

    Il sait quand une nouvelle "commande" (ExecutionPlan) arrive.
    Il mesure le temps n√©cessaire pour obtenir le premier "produit" (token).
    Il calcule la cadence de production (tokens/seconde).
    Il publie un rapport final √† la fin de chaque commande.

Notre usine n'est plus seulement r√©siliente et s√©curis√©e, elle est maintenant observable. Nous avons les outils pour mesurer et optimiser sa performance.