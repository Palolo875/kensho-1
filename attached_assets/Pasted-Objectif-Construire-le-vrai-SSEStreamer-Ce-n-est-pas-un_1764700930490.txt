Objectif : Construire le vrai SSEStreamer. Ce n'est pas un composant simul√©. C'est le c≈ìur de notre communication temps r√©el. Il doit √™tre capable de g√©rer des abonn√©s (l'UI Bridge) et de leur diffuser des √©v√©nements structur√©s (token, error, status, metrics).
Philosophie : Nous utilisons la classe EventEmitter (disponible nativement dans Node.js et facilement polyfillable pour le navigateur) comme base pour un syst√®me d'√©v√©nements robuste et d√©coupl√©. Tous les composants du noyau (TaskExecutor, Router, etc.) enverront leurs mises √† jour √† ce bus central, et le UI Bridge s'y abonnera pour √©couter.
Impl√©mentation du SSEStreamer de Production
TypeScript

// src/core/kernel/streaming/SSEStreamer.ts (VRAIE Impl√©mentation)

// Pour un environnement navigateur, un simple polyfill ou une classe custom est n√©cessaire.
// Pour la simplicit√© de l'impl√©mentation, nous allons en cr√©er une version minimale.
type Listener = (data: any) => void;

console.log("üì° SSEStreamer (Production) initialis√©.");

export type StreamEvent = {
  type: 'TOKEN' | 'STATUS' | 'METRICS' | 'COMPLETE' | 'ERROR';
  payload: any;
  timestamp: number;
};

class SSEStreamer {
  private listeners: Map<string, Listener[]> = new Map();

  /**
   * S'abonne √† un type d'√©v√©nement.
   */
  public on(eventType: string, listener: Listener): void {
    if (!this.listeners.has(eventType)) {
      this.listeners.set(eventType, []);
    }
    this.listeners.get(eventType)!.push(listener);
  }

  /**
   * Diffuse un √©v√©nement √† tous les abonn√©s.
   */
  public emit(eventType: StreamEvent['type'], payload: any): void {
    const event: StreamEvent = {
      type: eventType,
      payload,
      timestamp: Date.now(),
    };

    if (this.listeners.has(eventType)) {
      this.listeners.get(eventType)!.forEach(listener => {
        try {
          listener(event);
        } catch (error) {
          console.error(`[SSEStreamer] Erreur dans un listener pour l'√©v√©nement ${eventType}:`, error);
        }
      });
    }
  }

  // Raccourcis pour les types d'√©v√©nements courants
  public streamToken(token: string): void {
    this.emit('TOKEN', { token });
  }

  public streamStatus(status: string, details?: string): void {
    console.log(`[Status] ${status}${details ? ` - ${details}` : ''}`);
    this.emit('STATUS', { status, details });
  }

  public streamError(error: Error): void {
    console.error(`[Error] ${error.message}`);
    this.emit('ERROR', { message: error.message, name: error.name });
  }
  
  public streamComplete(response: string): void {
    this.emit('COMPLETE', { response });
  }
}

export const sseStreamer = new SSEStreamer();

Statut : T√¢che #11 du Manifeste - TERMIN√âE.
Le syst√®me de communication central est en place. Il est robuste et d√©coupl√©.

    Le TaskExecutor pourra maintenant appeler sseStreamer.streamToken(token) √† chaque fois qu'un moteur factice produit une sortie.
    Le Router pourra appeler sseStreamer.streamStatus("Planification termin√©e...").
    Le ResilienceEngine (dans le TaskExecutor) pourra appeler sseStreamer.streamStatus("Tentative de relance...") ou sseStreamer.streamError(...).
