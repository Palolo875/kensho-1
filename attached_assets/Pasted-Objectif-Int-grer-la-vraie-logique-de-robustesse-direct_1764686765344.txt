Objectif : Int√©grer la vraie logique de robustesse directement dans notre TaskExecutor. Nous allons le rendre capable de survivre √† des √©checs de t√¢ches (simul√©es) et de g√©rer des d√©lais excessifs.
Philosophie "Usine Vide" : Nous allons modifier notre moteur factice pour qu'il puisse simuler des pannes. Par exemple, une t√¢che sur trois √©chouera, et une sur cinq sera extr√™mement lente. Notre TaskExecutor devra g√©rer ces sc√©narios sans s'effondrer.
√âtape 1 : Mise √† jour du Moteur Factice pour simuler des pannes
TypeScript

// src/core/runtime/mocks/mock-engines.ts (Mise √† jour)

let requestCount = 0;

export const mockWebLLMEngine = {
  name: "MockWebLLM",
  type: "GPU",
  async generate(prompt: string, options?: { signal?: AbortSignal }): Promise<string> {
    requestCount++;
    console.log(`[Mock WebLLM] G√©n√©ration (Requ√™te #${requestCount})...`);

    // Simuler une panne une fois sur trois
    if (requestCount % 3 === 0) {
      await new Promise(r => setTimeout(r, 50));
      throw new Error("Erreur GPU simul√©e : Surcharge du kernel CUDA.");
    }

    // Simuler une t√¢che lente une fois sur cinq
    if (requestCount % 5 === 0) {
      console.log("[Mock WebLLM] T√¢che lente simul√©e (5 secondes)...");
      await new Promise(r => setTimeout(r, 5000));
    }

    // G√©rer l'annulation par timeout
    if (options?.signal?.aborted) {
      throw new Error("Op√©ration annul√©e par timeout.");
    }

    await new Promise(r => setTimeout(r, 150));
    return `R√©ponse simul√©e (rapide, via GPU) pour : "${prompt}"`;
  },
  // ...
};

√âtape 2 : Impl√©mentation du ResilienceEngine dans le TaskExecutor
Nous ne cr√©ons pas une nouvelle classe, nous int√©grons ces capacit√©s directement dans le TaskExecutor.
TypeScript

// src/core/kernel/TaskExecutor.ts (Mise √† jour majeure)

import { runtimeManager } from './RuntimeManager';
import { ExecutionPlan, Task } from './ExecutionPlan';
import pLimit from 'p-limit';

console.log("üë∑ TaskExecutor v3.1 (avec ResilienceEngine) initialis√©.");

const TASK_TIMEOUT_MS = 3000; // Timeout de 3 secondes par t√¢che
const MAX_RETRIES = 2; // 2 tentatives de plus (total 3)
const RETRY_DELAY_MS = 200; // D√©lai initial avant la premi√®re tentative

class TaskExecutor {
  private limit: any;

  constructor() {
    this.limit = pLimit(2);
  }

  public async executePlan(plan: ExecutionPlan): Promise<any[]> {
    const engine = await runtimeManager.getEngine();

    const taskPromises = plan.tasks.map(task => {
      const taskFn = () => this.executeTaskWithResilience(task, engine);
      
      if (plan.strategy === 'PARALLEL_LIMITED') {
        return this.limit(taskFn);
      }
      return taskFn();
    });
    
    // ... (logique SERIAL vs PARALLEL inchang√©e)
    // ...
  }

  /**
   * Ex√©cute une seule t√¢che avec timeout et retry.
   */
  private async executeTaskWithResilience(task: Task, engine: any): Promise<any> {
    for (let attempt = 1; attempt <= MAX_RETRIES + 1; attempt++) {
      try {
        console.log(`[TaskExecutor] Lancement t√¢che "${task.model}" (Essai ${attempt})...`);
        
        const abortController = new AbortController();
        const timeoutId = setTimeout(() => abortController.abort(), TASK_TIMEOUT_MS);

        const result = await engine.generate(task.prompt, { signal: abortController.signal });
        
        clearTimeout(timeoutId); // Annuler le timeout si la t√¢che r√©ussit
        return { expert: task.model, result, status: 'success' };

      } catch (error) {
        const err = error as Error;
        console.warn(`[TaskExecutor] ‚ö†Ô∏è Erreur sur "${task.model}" (Essai ${attempt}): ${err.message}`);

        if (attempt > MAX_RETRIES) {
          console.error(`[TaskExecutor] ‚ùå √âchec final pour "${task.model}" apr√®s ${attempt} essais.`);
          return { expert: task.model, error: err.message, status: 'error' };
        }

        // Attendre avant la prochaine tentative (backoff exponentiel simple)
        const delay = RETRY_DELAY_MS * Math.pow(2, attempt - 1);
        console.log(`[TaskExecutor] Prochaine tentative dans ${delay}ms...`);
        await new Promise(r => setTimeout(r, delay));
      }
    }
  }
}

export const taskExecutor = new TaskExecutor();

Statut : T√¢che #10 du Manifeste - TERMIN√âE.
Notre TaskExecutor n'est plus un simple chef de chantier. C'est un v√©t√©ran aguerri.

    Il est patient : Il sait attendre et r√©essayer si une t√¢che √©choue.
    Il est pragmatique : Il sait abandonner une t√¢che si elle prend trop de temps (timeout).
    Il est r√©silient : Une panne sur un "ouvrier" (un mod√®le) ne fait plus s'effondrer toute la cha√Æne de production.
