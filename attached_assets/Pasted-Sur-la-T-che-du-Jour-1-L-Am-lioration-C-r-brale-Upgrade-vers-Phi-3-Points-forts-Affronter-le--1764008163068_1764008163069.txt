Sur la Tâche du Jour 1 : L'Amélioration Cérébrale - Upgrade vers Phi-3
Points forts : Affronter le "risque" d'un modèle plus lourd dès le début du sprint est une stratégie intelligente – ça valide tôt si l'app scale avec des modèles réalistes (Phi-3-mini-4k est un excellent choix : ~3.8B params, instruct-tuned, bien meilleur que TinyLlama pour du reasoning et des réponses naturelles, tout en restant gérable on-device). Changer juste une constante dans le LLMAgent montre à quel point ton archi est modulaire et flexible. La validation immédiate (build, run, observe loading + démo) est pragmatique : focus sur UX (loading feedback) et qualité (réponses plus cohérentes). Si le streaming tient toujours (ce qui devrait, vu que web-llm gère ça nativement), c'est un win massif.
Potentiel d'amélioration : Ajoute un fallback dans ModelLoader pour switcher à un modèle lighter si Phi-3 fail (ex. : GPU insuffisant). Mesure les temps (download ~GBs la 1ère fois, compile plus longue) et log-les pour benchmark. Teste des queries complexes (ex. : "Explique un algo de tri en code") pour voir le gap qualitatif vs. TinyLlama. Si latence trop haute, envisage q4f16 ou un plus petit quant.
Sur la Tâche des Jours 2-3 : Création du CalculatorAgent et son Manifeste
Points forts : La philosophie "expert idiot" est spot on – limiter l'agent à UNE chose (éval math sécurisée) le rend fiable et sécurisé. Utiliser mathjs au lieu d'eval() est crucial pour éviter les injections (bravo pour la justification). Le manifest est génial : structuré pour LLM (name, desc, methods avec args/desc/exemples) – ça prépare parfaitement un TaskPlanner plus smart qui "lira" ces manifests pour router. L'implé est clean : config mathjs safe, validation input, handling de résultats non-sérialisables, logs pour trace. Retourner des erreurs claires permet à l'OIE de retry ou fallback gracieusement.
Potentiel d'amélioration : Dans mathjs config, ajoute des scopes limités (ex. : importer seulement les funcs nécessaires pour éviter bloat). Pour le manifest, rends-le exportable/découvrable dynamiquement (ex. : un registry central des manifests). Dans l'agent, supporte des unités/conversions (comme dans l'exemple "5cm to inch") – mathjs le gère natif, cool. Ajoute un timeout sur evaluate pour les exprs infinies.
Sur les Tests Unitaires (CalculatorAgent.test.ts)
Points forts : Extraire la logique pure (evaluateExpression) pour tester est une best practice – ça rend les tests simples et focus sur le core (bons cas : simple calc, div/0, invalid). Utiliser un mock temporaire est ok pour bootstrap, mais idéal pour valider sécurité (ex. : test expr malicieuse comme "process.exit()").
Potentiel d'amélioration : Flesh out avec plus de cas (ex. : trig funcs, matrices simples si supporté). Intègre le vrai mathjs dans les tests (pas mock) pour coverage réel. Ajoute des tests pour le full payload (ex. : invalid type).
Avis Global sur le Sprint 3 (Jusqu'ici)
Ce qui rocks : Tu passes à la vitesse supérieure – upgrade modèle + premier tool agent concret, c'est le début d'un vrai multi-agent system. Avec Phi-3, Kensho devient "intelligent" pour de vrai (meilleures réponses, potentiellement capable de planner via prompts). Le CalculatorAgent est un template parfait pour futurs tools (ex. : WeatherAPI, CodeExecutor) – sécurisé, manifest-driven. L'ensemble valide que ton bus/OIE gère bien les appels sync (calculate retourne un scalar, pas stream).
Risques potentiels : Avec Phi-3, surveille la mémoire browser (web-llm peut eater du VRAM). Test e2e : UI query comme "Calcule 2+2" → OIE (naïf) → si route vers Calc, win ; sinon, up le planner soon. Si mathjs ajoute du bundle size, check impact sur workers.