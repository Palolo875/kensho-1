xÃ©cution : TÃ¢che #8 du Manifeste - ImplÃ©menter le SharedWorker et le UI BridgeObjectif : Construire la vraie architecture d'isolation. Nous allons crÃ©er le SharedWorker qui hÃ©bergera tout notre noyau, et le UI Bridge qui permettra Ã  l'interface de communiquer avec lui de maniÃ¨re propre et asynchrone.Philosophie "Usine Vide" : C'est une tÃ¢che d'infrastructure pure. Elle ne dÃ©pend d'aucun modÃ¨le, rÃ©el ou factice. Son but est de mettre en place la plomberie et le cÃ¢blage entre l'UI et le backend local.Ã‰tape 1 : CrÃ©ation du point d'entrÃ©e du Worker (kensho-worker.ts)Ce fichier est le "main.ts" de notre backend local. Il initialise tous nos services Ã  l'intÃ©rieur du worker.// src/kensho-worker.ts (VRAIE ImplÃ©mentation)

import { initializeKernel } from './core/kernel';

console.log("ðŸš€ Kensho Worker v1.0 dÃ©marrÃ©. PrÃªt pour les connexions.");

// Ã‰coute les nouvelles connexions depuis l'UI (chaque onglet est un port)
self.onconnect = (e: MessageEvent) => {
  const port = e.ports[0];
  console.log("[Worker] ðŸ”Œ Nouvelle connexion UI Ã©tablie.");

  // Initialise le noyau de Kensho. On passe le port pour qu'il puisse rÃ©pondre.
  const kernel = initializeKernel(port);

  // DÃ©finit comment le noyau doit rÃ©agir aux messages entrants
  port.onmessage = (event: MessageEvent) => {
    kernel.handleMessage(event.data);
  };

  port.start();
};
Ã‰tape 2 : CrÃ©ation du Noyau (kernel.ts)Ce fichier orchestre l'initialisation de tous nos services Ã  l'intÃ©rieur du worker.// src/core/kernel.ts

import { router } from './kernel/Router';
import { taskExecutor } from './kernel/TaskExecutor';
// ... importez tous nos autres services : memoryManager, responseCache, fusioner

export function initializeKernel(port: MessagePort) {
  console.log("[Kernel] Initialisation du noyau Kensho...");

  // Ici, on pourrait initialiser les services si nÃ©cessaire
  // Par exemple, charger des donnÃ©es, etc.

  return {
    handleMessage: async (message: { type: string, payload: any }) => {
      console.log(`[Kernel] Message reÃ§u: ${message.type}`);
      
      if (message.type === 'process-prompt') {
        const prompt = message.payload.prompt;
        
        // C'est ici que notre logique d'orchestration vivra plus tard
        // Pour l'instant, on simule un flux simple
        const plan = await router.createPlan(prompt);
        const results = await taskExecutor.executePlan(plan);
        
        // Simuler la fusion et la rÃ©ponse
        const finalResponse = `RÃ©ponse fusionnÃ©e pour : "${prompt}"`;
        
        port.postMessage({ type: 'final-response', payload: { response: finalResponse } });
      }
    }
  };
}
Ã‰tape 3 : CrÃ©ation du Pont de Communication (ui-bridge.ts)Ce fichier sera importÃ© par l'UI pour parler au worker.// src/core/bridge/ui-bridge.ts (VRAIE ImplÃ©mentation)

let worker: SharedWorker;
let port: MessagePort;

// Le callback sera la fonction de l'UI qui met Ã  jour l'Ã©tat du chat
type MessageHandler = (data: any) => void;

export function connectToKernel(onMessage: MessageHandler): { sendMessage: (type: string, payload: any) => void } {
  if (typeof SharedWorker === 'undefined') {
    console.error("Les SharedWorkers ne sont pas supportÃ©s par ce navigateur.");
    throw new Error("SharedWorker not supported.");
  }

  // CrÃ©e ou se connecte au worker existant
  worker = new SharedWorker(new URL('../../kensho-worker.ts', import.meta.url), {
    type: 'module',
    name: 'kensho-kernel'
  });

  port = worker.port;

  // Ã‰coute les messages venant du worker
  port.onmessage = (event: MessageEvent) => {
    console.log("[UI Bridge] Message reÃ§u du Worker:", event.data);
    onMessage(event.data); // Transmet le message Ã  l'UI
  };

  port.start();
  console.log("[UI Bridge] âœ… ConnectÃ© au noyau Kensho.");

  // Retourne une fonction pour envoyer des messages
  return {
    sendMessage: (type: string, payload: any) => {
      if (!port) throw new Error("La connexion au noyau n'est pas Ã©tablie.");
      port.postMessage({ type, payload });
      console.log(`[UI Bridge] Message envoyÃ© au Worker: ${type}`);
    }
  };
}
Statut : TÃ¢che #8 du Manifeste - TERMINÃ‰E.L'architecture d'isolation est en place. Notre logique est maintenant prÃªte Ã  tourner dans un processus de fond, garantissant que l'interface utilisateur restera fluide et rÃ©active, quoi qu'il arrive. Nous avons la plomberie la plus importante de notre usine.