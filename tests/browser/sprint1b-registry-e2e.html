<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <title>Kensho - Sprint 1B - Test E2E du WorkerRegistry</title>
    <style>
        body {
            font-family: system-ui, sans-serif;
            line-height: 1.6;
            padding: 2em;
            background-color: #1e1e1e;
            color: #d4d4d4;
        }

        pre {
            background-color: #282c34;
            padding: 1em;
            border-radius: 8px;
            white-space: pre-wrap;
            font-family: 'Courier New', Courier, monospace;
        }

        button {
            font-size: 1.2em;
            padding: 0.5em 1em;
            cursor: pointer;
            border-radius: 5px;
            border: 1px solid #61afef;
            background-color: #282c34;
            color: #61afef;
        }

        button:hover {
            background-color: #3e4451;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        h1,
        h2 {
            color: #61afef;
        }

        .pass {
            color: #98c379;
            font-weight: bold;
        }

        .fail {
            color: #e06c75;
            font-weight: bold;
        }

        .info {
            color: #56b6c2;
        }

        .warning {
            color: #e5c07b;
        }

        .summary {
            margin-top: 1em;
            border-top: 1px solid #444;
            padding-top: 1em;
        }
    </style>
</head>

<body>
    <h1>üõ°Ô∏è Sprint 1B - Test E2E du WorkerRegistry</h1>
    <p>Ce test valide que les agents se d√©couvrent mutuellement et que les agents inactifs sont correctement retir√©s du
        registre.</p>
    <button id="run-tests">Lancer les Tests</button>
    <h2>R√©sultats :</h2>
    <pre id="results"></pre>

    <script type="module">
        const resultsEl = document.getElementById('results');
        const log = (message, status = 'info') => {
            const line = document.createElement('div');
            line.innerHTML = `<span class="${status}">[${status.toUpperCase()}] ${message}</span>`;
            resultsEl.appendChild(line);
            console.log(`[${status.toUpperCase()}] ${message}`);
        };

        // Helper pour attendre un certain temps
        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        // Helper pour d√©marrer un worker et attendre son signal READY
        function startWorker(name, path) {
            const worker = new Worker(path, { type: 'module', name: name });
            const readyPromise = new Promise((resolve, reject) => {
                const timeoutId = setTimeout(() => reject(new Error(`Worker ${name} n'a pas d√©marr√© √† temps.`)), 5000);
                worker.onmessage = (e) => {
                    if (e.data && e.data.type === 'READY') {
                        clearTimeout(timeoutId);
                        worker.onmessage = null; // D√©sactiver apr√®s READY
                        resolve(worker);
                    }
                };
                worker.onerror = (err) => {
                    clearTimeout(timeoutId);
                    reject(err);
                };
            });
            return readyPromise;
        }

        document.getElementById('run-tests').addEventListener('click', async () => {
            const btn = document.getElementById('run-tests');
            btn.disabled = true;
            resultsEl.innerHTML = '';
            log('--- D√©marrage du test du WorkerRegistry ---', 'info');

            const { MessageBus } = await import('/src/core/communication/MessageBus.ts');
            const mainBus = new MessageBus('MainThread');
            let workers = {};
            let testPassed = true;

            try {
                // --- √âtape 1: D√©marrage et D√©couverte ---
                log('\n[√âtape 1] D√©marrage de 3 agents et v√©rification de la d√©couverte mutuelle...', 'info');

                const workerNames = ['AgentA', 'AgentB', 'AgentC'];
                const workerPromises = workerNames.map(name =>
                    startWorker(name, '/dist/test-agents/ping.agent.js')
                );

                const startedWorkers = await Promise.all(workerPromises);
                workerNames.forEach((name, i) => workers[name] = startedWorkers[i]);
                log('  ‚úì Tous les agents ont d√©marr√©.', 'pass');

                // Laisser un peu de temps pour que les annonces se propagent
                log('  Attente de 2 secondes pour la propagation des annonces...', 'info');
                await sleep(2000);

                // Interroger chaque worker pour conna√Ætre son registre
                for (const name of workerNames) {
                    try {
                        const activeList = await mainBus.request(name, { method: 'getActiveWorkers', args: [] }, 3000);
                        log(`  Registre de ${name}: [${activeList.sort().join(', ')}]`, 'info');

                        // Chaque worker doit conna√Ætre tous les autres
                        const expectedWorkers = workerNames.filter(n => n !== name);
                        const hasAllOthers = expectedWorkers.every(n => activeList.includes(n));
                        const hasSelf = activeList.includes(name);

                        if (hasSelf && hasAllOthers && activeList.length === workerNames.length) {
                            log(`  ‚úì Le registre de ${name} est correct (${activeList.length} agents).`, 'pass');
                        } else {
                            log(`  ‚úó ERREUR: Le registre de ${name} est incorrect.`, 'fail');
                            log(`    Attendu: ${workerNames.length} agents, Re√ßu: ${activeList.length}`, 'fail');
                            testPassed = false;
                        }
                    } catch (error) {
                        log(`  ‚úó Erreur lors de la requ√™te √† ${name}: ${error.message}`, 'fail');
                        testPassed = false;
                    }
                }

                if (!testPassed) throw new Error("La phase de d√©couverte a √©chou√©.");

                // --- √âtape 2: Arr√™t d'un agent et v√©rification du nettoyage ---
                log('\n[√âtape 2] Arr√™t de l\'AgentB et v√©rification du nettoyage du registre...', 'info');

                workers['AgentB'].terminate();
                delete workers['AgentB'];
                log('  ‚úì AgentB termin√©.', 'pass');

                // Attendre plus longtemps que le INACTIVITY_THRESHOLD (10s) + le cleanupInterval (5s)
                // Soyons g√©n√©reux et attendons 16 secondes
                const waitTime = 16000;
                log(`  ‚è≥ Attente de ${waitTime / 1000} secondes pour le garbage collector...`, 'warning');
                log('  (Ceci est normal, le WorkerRegistry utilise un seuil de 10s d\'inactivit√©)', 'info');

                // Afficher un compte √† rebours
                for (let i = waitTime / 1000; i > 0; i--) {
                    await sleep(1000);
                    if (i % 2 === 0) {
                        log(`    ${i} secondes restantes...`, 'info');
                    }
                }

                const remainingWorkers = ['AgentA', 'AgentC'];
                log('\n  V√©rification des registres apr√®s nettoyage...', 'info');

                for (const name of remainingWorkers) {
                    try {
                        const activeList = await mainBus.request(name, { method: 'getActiveWorkers', args: [] }, 3000);
                        log(`  Registre de ${name}: [${activeList.sort().join(', ')}]`, 'info');

                        // Le registre ne doit plus contenir AgentB
                        const stillHasB = activeList.includes('AgentB');
                        const hasCorrectCount = activeList.length === remainingWorkers.length;

                        if (!stillHasB && hasCorrectCount) {
                            log(`  ‚úì Le registre de ${name} a √©t√© nettoy√© correctement.`, 'pass');
                        } else {
                            if (stillHasB) {
                                log(`  ‚úó ERREUR: Le registre de ${name} contient toujours AgentB !`, 'fail');
                            }
                            if (!hasCorrectCount) {
                                log(`  ‚úó ERREUR: Le registre de ${name} a ${activeList.length} agents au lieu de ${remainingWorkers.length}.`, 'fail');
                            }
                            testPassed = false;
                        }
                    } catch (error) {
                        log(`  ‚úó Erreur lors de la requ√™te √† ${name}: ${error.message}`, 'fail');
                        testPassed = false;
                    }
                }

            } catch (error) {
                log(`\n‚ùå Erreur critique durant le test: ${error.message}`, 'fail');
                console.error(error);
                testPassed = false;
            } finally {
                // Nettoyage final
                log('\n--- Nettoyage ---', 'info');
                Object.values(workers).forEach(w => {
                    try {
                        w.terminate();
                    } catch (e) {
                        // Ignorer les erreurs de terminaison
                    }
                });
                mainBus.dispose();

                log('\n--- Test Termin√© ---', 'summary');
                if (testPassed) {
                    log('üéâ T√¢che "WorkerRegistry" valid√©e avec succ√®s !', 'pass');
                    log('‚úì Tous les agents se sont d√©couverts correctement', 'pass');
                    log('‚úì Le garbage collector fonctionne comme pr√©vu', 'pass');
                } else {
                    log('‚ùóÔ∏è Des probl√®mes ont √©t√© d√©tect√©s dans le WorkerRegistry.', 'fail');
                }

                btn.disabled = false;
            }
        });
    </script>
</body>

</html>