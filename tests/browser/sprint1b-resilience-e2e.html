<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <title>Kensho - Sprint 1B - Test E2E de R√©silience</title>
    <style>
        body {
            font-family: system-ui, sans-serif;
            line-height: 1.6;
            padding: 2em;
            background-color: #1e1e1e;
            color: #d4d4d4;
        }

        pre {
            background-color: #282c34;
            padding: 1em;
            border-radius: 8px;
            white-space: pre-wrap;
            font-family: 'Courier New', Courier, monospace;
        }

        button {
            font-size: 1.2em;
            padding: 0.5em 1em;
            cursor: pointer;
            border-radius: 5px;
            border: 1px solid #61afef;
            background-color: #282c34;
            color: #61afef;
        }

        button:hover {
            background-color: #3e4451;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        h1,
        h2 {
            color: #61afef;
        }

        .pass {
            color: #98c379;
            font-weight: bold;
        }

        .fail {
            color: #e06c75;
            font-weight: bold;
        }

        .info {
            color: #56b6c2;
        }

        .warning {
            color: #e5c07b;
        }

        .summary {
            margin-top: 1em;
            border-top: 1px solid #444;
            padding-top: 1em;
        }
    </style>
</head>

<body>
    <h1>Sprint 1B - Test E2E de R√©silience (Heartbeat & Panne)</h1>
    <p>Ce test valide que la constellation peut survivre √† la perte de son leader.</p>
    <button id="run-tests">Lancer le Test de R√©silience</button>
    <h2>R√©sultats :</h2>
    <pre id="results"></pre>

    <script type="module">
        const resultsEl = document.getElementById('results');
        const log = (message, status = 'info') => {
            const line = document.createElement('div');
            line.innerHTML = `<span class="${status}">[${status.toUpperCase()}] ${message}</span>`;
            resultsEl.appendChild(line);
            console.log(`[${status.toUpperCase()}] ${message}`);
        };

        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        function startWorker(path, name) {
            const worker = new Worker(path, { type: 'module', name: name });
            const readyPromise = new Promise((resolve, reject) => {
                const timeoutId = setTimeout(() => reject(new Error(`Worker ${name} n'a pas d√©marr√© √† temps.`)), 5000);
                worker.onmessage = (e) => {
                    if (e.data && e.data.type === 'READY') {
                        clearTimeout(timeoutId);
                        worker.onmessage = null;
                        resolve(worker);
                    }
                };
                worker.onerror = (err) => {
                    clearTimeout(timeoutId);
                    reject(err);
                };
            });
            return readyPromise;
        }

        document.getElementById('run-tests').addEventListener('click', async () => {
            const btn = document.getElementById('run-tests');
            btn.disabled = true;
            resultsEl.innerHTML = '';
            log('--- D√©marrage du test de r√©silience ---', 'info');

            const { MessageBus } = await import('/src/core/communication/MessageBus.ts');
            const mainBus = new MessageBus('MainThread');
            let workers = {};
            let testPassed = true;

            try {
                // --- √âtape 1: √âlection initiale ---
                const agentNames = ['AgentA', 'AgentB', 'AgentC'];
                const initialExpectedLeader = 'AgentC';
                log(`[√âtape 1] D√©marrage de ${agentNames.length} agents. Leader initial attendu: '${initialExpectedLeader}'.`);

                const startedWorkers = await Promise.all(agentNames.map(name => startWorker('/dist/test-agents/ping.agent.js', name)));
                agentNames.forEach((name, i) => workers[name] = { worker: startedWorkers[i], name });
                log('  Agents pr√™ts.', 'pass');

                await sleep(4000); // Attendre la fin de la premi√®re √©lection

                const statuses1 = await Promise.all(agentNames.map(name => mainBus.request(name, { method: 'getGuardianStatus', args: [] })));
                const firstLeader = statuses1[0].leader;

                // V√©rifier que tout le monde est d'accord
                const allAgree = statuses1.every(s => s.leader === firstLeader);
                if (!allAgree) {
                    throw new Error(`D√©saccord initial sur le leader: ${statuses1.map(s => s.leader).join(', ')}`);
                }

                if (firstLeader !== initialExpectedLeader) {
                    throw new Error(`L'√©lection initiale a √©chou√©. Leader √©lu: ${firstLeader}, Attendu: ${initialExpectedLeader}`);
                }
                log(`  √âlection initiale r√©ussie. Leader est bien '${firstLeader}'.`, 'pass');

                // --- √âtape 2: Panne du Leader ---
                log(`\n[√âtape 2] Simulation de la panne du leader '${firstLeader}'...`, 'info');
                workers[firstLeader].worker.terminate();
                delete workers[firstLeader];
                const remainingAgentNames = Object.keys(workers);
                const newExpectedLeader = 'AgentB';
                log(`  '${firstLeader}' termin√©. Agents restants: [${remainingAgentNames.join(', ')}]. Nouveau leader attendu: '${newExpectedLeader}'.`);

                // --- √âtape 3: Nouvelle √âlection et V√©rification ---
                // Attendre le seuil de d√©tection de panne (6s) + le temps d'√©lection (3s)
                const reElectionTime = 9000;
                log(`[√âtape 3] Attente de ${reElectionTime / 1000}s pour la d√©tection de panne et la nouvelle √©lection...`, 'info');
                await sleep(reElectionTime);

                const statuses2 = await Promise.all(remainingAgentNames.map(name => mainBus.request(name, { method: 'getGuardianStatus', args: [] })));

                let consensusFailed = false;
                const secondLeader = statuses2[0].leader;
                statuses2.forEach(status => {
                    if (status.leader !== secondLeader) consensusFailed = true;
                });

                if (consensusFailed) {
                    throw new Error(`Les agents ne sont pas d'accord sur le nouveau leader ! ${statuses2.map(s => `${s.leader}`).join(', ')}`);
                }
                log('  Consensus atteint sur le nouveau leader.', 'pass');

                if (secondLeader === newExpectedLeader) {
                    log(`  Nouvelle √©lection r√©ussie. Le nouveau leader est bien '${secondLeader}'.`, 'pass');
                } else {
                    throw new Error(`Le nouveau leader √©lu ('${secondLeader}') n'est pas celui attendu ('${newExpectedLeader}').`);
                }

            } catch (error) {
                log(`Erreur critique durant le test: ${error.message}`, 'fail');
                console.error(error);
                testPassed = false;
            } finally {
                Object.values(workers).forEach(w => w.worker.terminate());
                mainBus.dispose();
                log('\n--- Test Termin√© ---', 'summary');
                if (testPassed) {
                    log('üéâ T√¢che "Heartbeat & D√©tection de Panne" valid√©e avec succ√®s !', 'pass');
                } else {
                    log('‚ùóÔ∏è Des probl√®mes ont √©t√© d√©tect√©s dans le cycle de r√©silience.', 'fail');
                }
                btn.disabled = false;
            }
        });
    </script>
</body>

</html>