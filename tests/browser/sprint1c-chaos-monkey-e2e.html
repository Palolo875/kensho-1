<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <title>Kensho - Sprint 1C - Test du Chaos (Chaos Monkey)</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1400px;
            margin: 40px auto;
            padding: 20px;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: #333;
        }

        h1 {
            color: white;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        p {
            color: #f0f0f0;
            text-align: center;
            font-size: 1.1rem;
        }

        button {
            display: block;
            margin: 20px auto;
            padding: 15px 30px;
            font-size: 1.2rem;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1.5em;
            margin-bottom: 2em;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.95);
            padding: 1.5em;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .stat-card h3 {
            margin: 0 0 0.5em 0;
            color: #555;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-card p {
            font-size: 2em;
            margin: 0;
            font-weight: bold;
            color: #333;
        }

        .stat-card.success p {
            color: #16a34a;
        }

        .stat-card.failure p {
            color: #dc2626;
        }

        .stat-card.rate p {
            color: #7c3aed;
        }

        #progress-bar {
            width: 100%;
            height: 30px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            overflow: hidden;
            margin-bottom: 1em;
        }

        #progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #16a34a 0%, #84cc16 100%);
            width: 0%;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }

        #results {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            min-height: 400px;
            max-height: 600px;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            line-height: 1.6;
            white-space: pre-wrap;
            overflow-y: auto;
        }

        .log-info {
            color: #2563eb;
        }

        .log-pass {
            color: #16a34a;
            font-weight: bold;
        }

        .log-fail {
            color: #dc2626;
            font-weight: bold;
        }

        .log-warn {
            color: #ea580c;
        }

        .log-chaos {
            color: #f5576c;
            font-weight: bold;
        }

        .log-repair {
            color: #7c3aed;
        }

        .log-summary {
            color: #7c3aed;
            font-weight: bold;
            font-size: 1.1rem;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 2px solid #e5e7eb;
        }
    </style>
</head>

<body>
    <h1>ğŸ’ Sprint 1C - Test du Chaos (Chaos Monkey)</h1>
    <p>Ce test valide la robustesse de la constellation en tuant et redÃ©marrant des agents alÃ©atoirement tout en
        effectuant des requÃªtes continues.</p>
    <button id="run-tests">ğŸš€ Lancer le Chaos ğŸ’</button>

    <div id="progress-bar">
        <div id="progress-fill">0%</div>
    </div>

    <div id="stats"></div>

    <h2 style="color: white; text-align: center;">ğŸ“Š Journal des Ã‰vÃ©nements :</h2>
    <pre id="results"></pre>

    <script type="module">
        const resultsEl = document.getElementById('results');
        const statsEl = document.getElementById('stats');
        const progressFill = document.getElementById('progress-fill');
        const runButton = document.getElementById('run-tests');

        const log = (message, status = 'info') => {
            const timestamp = new Date().toLocaleTimeString();
            const className = `log-${status}`;
            const line = document.createElement('span');
            line.className = className;
            line.textContent = `[${timestamp}] ${message}\n`;
            resultsEl.appendChild(line);
            resultsEl.scrollTop = resultsEl.scrollHeight;
        };

        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        // --- Configuration du Test ---
        const NUM_AGENTS = 5;
        const TEST_DURATION_MS = 30000; // 30 secondes de chaos
        const CHAOS_INTERVAL_MIN_MS = 2000;
        const CHAOS_INTERVAL_MAX_MS = 5000;
        const CLIENT_REQUEST_INTERVAL_MS = 200;

        let testRunning = false;

        function updateStats(stats, elapsed, total) {
            const successRate = stats.requests > 0
                ? ((stats.successes / stats.requests) * 100).toFixed(2)
                : '0.00';

            const progress = Math.min(100, (elapsed / total) * 100);
            progressFill.style.width = `${progress}%`;
            progressFill.textContent = `${progress.toFixed(0)}% - ${Math.floor((total - elapsed) / 1000)}s restantes`;

            statsEl.innerHTML = `
                <div class="stat-card">
                    <h3>Temps Ã‰coulÃ©</h3>
                    <p>${Math.floor(elapsed / 1000)}s / ${total / 1000}s</p>
                </div>
                <div class="stat-card">
                    <h3>RequÃªtes TentÃ©es</h3>
                    <p>${stats.requests}</p>
                </div>
                <div class="stat-card success">
                    <h3>âœ… SuccÃ¨s</h3>
                    <p>${stats.successes}</p>
                </div>
                <div class="stat-card failure">
                    <h3>âŒ Ã‰checs</h3>
                    <p>${stats.failures}</p>
                </div>
                <div class="stat-card rate">
                    <h3>ğŸ“ˆ Taux de SuccÃ¨s</h3>
                    <p>${successRate}%</p>
                </div>
            `;
        }

        runButton.addEventListener('click', async () => {
            if (testRunning) return;
            testRunning = true;
            runButton.disabled = true;
            resultsEl.innerHTML = '';
            statsEl.innerHTML = '';

            log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', 'summary');
            log('    ğŸ’ DÃ‰MARRAGE DU TEST DU CHAOS', 'summary');
            log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', 'summary');
            log('');

            const { MessageBus } = await import('/src/core/communication/MessageBus.ts');
            const mainBus = new MessageBus('MainThread');
            let workers = new Map();
            let stats = { requests: 0, successes: 0, failures: 0 };
            let startTime = Date.now();

            // --- Fonctions Helper ---
            async function startWorker(name) {
                try {
                    const worker = new Worker('/dist/test-agents/ping.agent.js', {
                        type: 'module',
                        name
                    });
                    workers.set(name, worker);
                    log(`  âœ… ${name} dÃ©marrÃ©`, 'pass');
                    return worker;
                } catch (error) {
                    log(`  âŒ Ã‰chec dÃ©marrage ${name}: ${error.message}`, 'fail');
                    return null;
                }
            }

            try {
                // --- Ã‰tape 1: Initialisation de la Constellation ---
                log(`[Ã‰tape 1] DÃ©marrage de ${NUM_AGENTS} agents...`, 'info');
                for (let i = 0; i < NUM_AGENTS; i++) {
                    await startWorker(`Agent${i}`);
                    await sleep(50); // Petit dÃ©lai pour Ã©viter les race conditions
                }
                await sleep(500); // Attendre que tous les agents s'enregistrent
                log('  ğŸ‰ Constellation initiale prÃªte !', 'pass');
                log('');

                // --- Ã‰tape 2: Lancement du Chaos Monkey ---
                log('[Ã‰tape 2] ğŸ’ Lancement du Chaos Monkey...', 'chaos');
                log(`  â†’ Intervalle de chaos: ${CHAOS_INTERVAL_MIN_MS}-${CHAOS_INTERVAL_MAX_MS}ms`, 'info');
                log('');

                let chaosRunning = true;

                // Chaos Monkey (tue et redÃ©marre des agents)
                const chaosLoop = async () => {
                    while (chaosRunning) {
                        await sleep(CHAOS_INTERVAL_MIN_MS + Math.random() * (CHAOS_INTERVAL_MAX_MS - CHAOS_INTERVAL_MIN_MS));

                        if (!chaosRunning || workers.size === 0) break;

                        const workerNames = Array.from(workers.keys());
                        const victimName = workerNames[Math.floor(Math.random() * workerNames.length)];
                        const victimWorker = workers.get(victimName);

                        if (victimWorker) {
                            log(`ğŸ’ğŸ’¥ Chaos Monkey tue ${victimName}...`, 'chaos');
                            victimWorker.terminate();
                            workers.delete(victimName);

                            // RedÃ©marrer aprÃ¨s un dÃ©lai
                            setTimeout(async () => {
                                if (chaosRunning) {
                                    log(`ğŸ”§ RÃ©paration: redÃ©marrage de ${victimName}...`, 'repair');
                                    await startWorker(victimName);
                                }
                            }, 800);
                        }
                    }
                };

                // DÃ©marrer le Chaos Monkey
                chaosLoop();

                // --- Ã‰tape 3: Client Continu ---
                log('[Ã‰tape 3] ğŸ“¡ Lancement du client de requÃªtes continues...', 'info');
                log(`  â†’ Intervalle de requÃªtes: ${CLIENT_REQUEST_INTERVAL_MS}ms`, 'info');
                log('');

                let clientRunning = true;
                const clientLoop = async () => {
                    while (clientRunning) {
                        await sleep(CLIENT_REQUEST_INTERVAL_MS);

                        if (!clientRunning || workers.size === 0) continue;

                        const workerNames = Array.from(workers.keys());
                        if (workerNames.length === 0) continue;

                        const targetName = workerNames[Math.floor(Math.random() * workerNames.length)];

                        stats.requests++;
                        try {
                            await mainBus.request(targetName, { method: 'ping', args: ['chaos-test'] }, 1500);
                            stats.successes++;
                        } catch (error) {
                            stats.failures++;
                            // Log uniquement les Ã©checs intÃ©ressants (pas tous pour ne pas spammer)
                            if (stats.failures % 5 === 0) {
                                log(`  âš ï¸  Ã‰chec intermittent (#${stats.failures}): ${targetName} - ${error.message.substring(0, 50)}`, 'warn');
                            }
                        }

                        const elapsed = Date.now() - startTime;
                        updateStats(stats, elapsed, TEST_DURATION_MS);
                    }
                };

                // DÃ©marrer le client
                clientLoop();

                // --- Ã‰tape 4: Attendre la fin du test ---
                log(`[Ã‰tape 4] â±ï¸  Test en cours pendant ${TEST_DURATION_MS / 1000} secondes...`, 'info');
                log('');
                await sleep(TEST_DURATION_MS);

                // --- Ã‰tape 5: ArrÃªt et Nettoyage ---
                chaosRunning = false;
                clientRunning = false;

                log('');
                log('[Ã‰tape 5] ğŸ›‘ ArrÃªt du chaos et nettoyage...', 'info');

                workers.forEach(w => {
                    try { w.terminate(); } catch (e) { }
                });
                workers.clear();
                mainBus.dispose();

                // --- Ã‰tape 6: Verdict Final ---
                log('');
                log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', 'summary');
                log('    ğŸ“Š RÃ‰SULTATS FINAUX DU TEST DU CHAOS', 'summary');
                log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', 'summary');
                log('');
                log(`  ğŸ“ˆ RequÃªtes totales: ${stats.requests}`, 'info');
                log(`  âœ… SuccÃ¨s: ${stats.successes}`, 'pass');
                log(`  âŒ Ã‰checs: ${stats.failures}`, 'fail');

                const finalSuccessRate = stats.requests > 0
                    ? (stats.successes / stats.requests) * 100
                    : 0;

                log(`  ğŸ¯ Taux de succÃ¨s: ${finalSuccessRate.toFixed(2)}%`, 'info');
                log('');

                if (finalSuccessRate >= 95) {
                    log('ğŸ‰ğŸ‰ğŸ‰ TEST RÃ‰USSI ! ğŸ‰ğŸ‰ğŸ‰', 'pass');
                    log('', 'pass');
                    log(`âœ… Taux de succÃ¨s de ${finalSuccessRate.toFixed(2)}% (> 95%)`, 'pass');
                    log('âœ… Le systÃ¨me est ROBUSTE et ANTI-FRAGILE !', 'pass');
                    log('âœ… Les mÃ©canismes de rÃ©silience fonctionnent correctement', 'pass');
                    log('âœ… OfflineQueue + Duplicate Detection ont prouvÃ© leur efficacitÃ©', 'pass');
                } else {
                    log('âŒ TEST Ã‰CHOUÃ‰', 'fail');
                    log('', 'fail');
                    log(`âŒ Taux de succÃ¨s de ${finalSuccessRate.toFixed(2)}% (< 95%)`, 'fail');
                    log('âŒ Le systÃ¨me n\'est pas assez robuste', 'fail');
                    throw new Error(`Taux de succÃ¨s trop bas: ${finalSuccessRate.toFixed(2)}%`);
                }

                log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', 'summary');

            } catch (error) {
                log('', 'fail');
                log(`ğŸ’¥ ERREUR CRITIQUE: ${error.message}`, 'fail');
                log('', 'fail');
            } finally {
                testRunning = false;
                runButton.disabled = false;
            }
        });
    </script>
</body>

</html>